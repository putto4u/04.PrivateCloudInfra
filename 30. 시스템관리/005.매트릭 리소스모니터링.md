# 챕터 5. IT 인프라 모니터링의 핵심 데이터: 메트릭(Metric)

클라우드 네이티브 환경과 마이크로서비스 아키텍처(MSA)가 도입되면서 시스템의 상태를 파악하는 **관측가능성(Observability)**이 중요해졌습니다. 메트릭은 로그(Log), 트레이스(Trace)와 함께 관측가능성을 구성하는 3대 기둥 중 하나이며, 가장 기본이 되는 정량적 데이터입니다.

본 장에서는 메트릭의 정의와 상세 구조, 프로메테우스의 데이터 모델, 그리고 효율적인 모니터링을 위한 설계 원칙을 통합하여 다룹니다.

---

## 1. 메트릭의 정의 및 특징

**메트릭(Metric)**이란 특정 시점의 시스템 상태를 나타내는 **숫자 데이터(Numeric Data)**입니다. "시스템이 지금 어떤 상태인가?"를 판단하는 가장 효율적인 지표입니다.

* **정량적 데이터:** 모든 정보가 수치로 표현되므로 저장 용량이 작고, 조회 속도가 빠릅니다.
* **시계열(Time-series):** 시간의 흐름에 따라 변화하는 값을 기록하여 추세를 파악하는 데 최적화되어 있습니다.
* **집계(Aggregation) 용이:** 평균, 합계, 최대/최소값 등의 통계적 연산이 매우 빠릅니다.

### 1.1. 메트릭과 프로메테우스의 관계

간단히 비유하자면 **메트릭**은 '측정된 데이터(숫자)'이고, **프로메테우스**는 그 데이터를 '수집, 저장, 관리하는 도구'입니다.

| 구분 | 메트릭 (Metric) | 프로메테우스 (Prometheus) |
| --- | --- | --- |
| **정의** | 시간에 따라 수집된 시스템의 상태 지표(숫자 데이터) | 메트릭을 수집하고 저장, 조회하는 오픈소스 시스템 |
| **역할** | CPU 사용률, 응답 시간, 에러 횟수 등 '값' 그 자체 | 데이터를 주기적으로 가져오고(Pull), 경고를 보냄 |
| **비유** | 자동차의 현재 속도, 연료 잔량 수치 | 이를 보여주고 관리하는 '계기판 및 블랙박스 시스템' |

---

## 2. 메트릭 vs 로그 vs 트레이스 비교

메트릭 하나만으로는 시스템의 모든 문제를 해결할 수 없습니다. 각 데이터의 역할과 차이를 명확히 구분해야 합니다.

| 구분 | 메트릭 (Metrics) | 로그 (Logs) | 트레이스 (Traces) |
| --- | --- | --- | --- |
| **질문** | "무슨 일이 일어나고 있는가?" | "왜 일어났는가?" | "어디서 일어났는가?" |
| **데이터 형태** | 수치 (숫자) | 텍스트 (문자열) | 호출 흐름 (스팬) |
| **장점** | 용량이 작고 조회가 빠릅니다. 대시보드 시각화에 최적화되어 있습니다. | 상세한 문맥 정보를 제공합니다. 특정 에러의 원인 파악이 가능합니다. | 마이크로서비스 간의 요청 경로 추적 및 병목 구간 확인이 가능합니다. |
| **단점** | 개별 사건의 구체적 내용은 알 수 없습니다. | 용량이 매우 크고, 검색 및 분석 비용이 높습니다. | 구축 난이도가 높고 오버헤드가 발생할 수 있습니다. |

---

## 3. 메트릭의 상세 구조 (Anatomy of a Metric)

현대적인 모니터링 시스템에서 메트릭은 단순한 숫자의 나열이 아닙니다. 데이터의 문맥(Context)을 포함하기 위해 **다차원 데이터 모델(Multi-dimensional Data Model)**을 사용합니다.

### 3.1. 데이터 기본 형식

### 3.2. 실제 데이터 예시와 상세 분석

프로메테우스가 수집하는 실제 텍스트 포맷 데이터를 해부하여 각 요소의 의미를 상세히 분석합니다.

**[데이터 예시]**

```text
http_requests_total{method="post", code="200"}  1024  1609459200000

```

**[구조 분해 및 주석]**

위 데이터를 4개의 핵심 컬럼(열)으로 나누어 설명하면 다음과 같습니다.

| 순서 | 구성 요소 (Column) | 실제 데이터 값 | 주석 및 설명 |
| --- | --- | --- | --- |
| **1** | **Metric Name** | `http_requests_total` | **무엇을 측정했는가?**<br>

<br>전체 HTTP 요청의 총 횟수를 의미하는 지표 이름입니다. |
| **2** | **Labels** | `{method="post", ...}` | **어떤 조건인가?**<br>

<br>데이터의 세부 속성입니다. POST 요청이면서 응답 코드가 200인 경우만 필터링합니다. |
| **3** | **Value** | `1024` | **측정값은 얼마인가?**<br>

<br>현재 시점까지 누적된 요청 횟수가 1,024번임을 나타내는 실수형(Float64) 숫자입니다. |
| **4** | **Timestamp** | `1609459200000` | **언제 측정했는가?**<br>

<br>데이터가 수집된 정확한 시각을 나타내는 유닉스 시간(Unix Time)입니다. |

### 3.3. 주요 속성 심층 탐구

데이터의 정확한 해석을 위해 레이블의 **메소드(Method)**와 **타임스탬프(Timestamp)**에 대한 이해가 필수적입니다.

#### 1) 메소드 (Method) 레이블

`method="post"`와 같은 레이블은 HTTP 프로토콜의 요청 방식을 의미하며, 서버가 수행한 동작의 성격을 나타냅니다.

* **GET:** 서버에서 데이터를 **조회**하는 요청입니다. (예: 게시글 목록 보기)
* **POST:** 서버에 데이터를 **생성**하거나 전송하는 요청입니다. (예: 로그인, 글 쓰기)
* **PUT/PATCH:** 데이터를 **수정**하는 요청입니다. (예: 회원 정보 변경)
* **DELETE:** 데이터를 **삭제**하는 요청입니다. (예: 게시글 지우기)

모니터링 시 `method` 레이블을 통해 "조회(GET)는 잘 되는데, 글 쓰기(POST)만 에러가 난다"와 같이 장애의 범위를 좁힐 수 있습니다.

#### 2) 타임스탬프 (Timestamp)

`1609459200000`과 같은 숫자는 사람이 읽기 힘든 형태지만, 컴퓨터가 시간을 처리하는 표준 방식인 **Unix Epoch Time**입니다.

* **정의:** 1970년 1월 1일 00:00:00(UTC)부터 현재까지 흐른 시간을 **밀리초(ms)** 단위로 나타낸 정수입니다.
* **변환 예시:** `1609459200000`  **2021년 1월 1일 00:00:00 (UTC)**
* **사용 이유:**
* **시간대(Timezone) 독립성:** 한국(KST), 미국(EST) 등 서버의 위치와 상관없이 전 세계 어디서나 동일한 기준 시각을 가집니다.
* **연산 효율성:** 날짜 포맷(YYYY-MM-DD)보다 단순한 정수형이므로 데이터베이스 저장 용량이 적고, 시간 차이 계산(뺄셈)이 매우 빠릅니다.



---

## 4. 프로메테우스 메트릭의 4가지 유형

프로메테우스는 수집하는 메트릭 데이터를 성격에 따라 4가지 모델로 분류하여 관리합니다.

1. **Counter (카운터)**
* **특징:** 0부터 시작하여 **항상 증가**만 하는 누적 값입니다. (시스템 재시작 시 0으로 초기화 가능)
* **용도:** 전체 요청 횟수, 발생한 에러 총합, 완료된 작업 수.


2. **Gauge (게이지)**
* **특징:** 숫자가 **올라가거나 내려갈 수** 있는 값입니다.
* **용도:** 현재 메모리 사용량, 현재 실행 중인 스레드 수, 온도.


3. **Histogram (히스토그램)**
* **특징:** 관측값의 분포를 **버킷(Bucket)** 형태로 나누어 측정합니다.
* **용도:** 응답 시간(Latency) 분포 (예: 1초 이내 요청이 몇 개인지 확인).


4. **Summary (요약)**
* **특징:** 히스토그램과 비슷하지만, 클라이언트 측에서 분위수(Quantile)를 직접 계산합니다.
* **용도:** 정확한 백분위 수치가 필요할 때 사용합니다.



---

## 5. 메트릭 설계의 핵심: 카디널리티(Cardinality)

매트릭 시스템 설계 및 운영 시 가장 주의해야 할 개념은 **카디널리티(Cardinality)**입니다. 카디널리티란 특정 매트릭이 가질 수 있는 고유한 레이블 값의 조합(Combination) 개수를 의미합니다.

### 5.1. 카디널리티 폭발 (Cardinality Explosion)

레이블(Label)에 무제한으로 증가할 수 있는 값을 사용하면, 시계열 데이터베이스의 인덱스 크기가 메모리 용량을 초과하여 시스템 장애를 유발합니다. 이를 '카디널리티 폭발'이라고 합니다.

* **좋은 레이블 예시 (Low Cardinality):**
* `region`: us-east-1, ap-northeast-2 (유한한 값)
* `method`: GET, POST (고정된 값)
* `status_code`: 200, 404, 500 (제한된 범위)


* **나쁜 레이블 예시 (High Cardinality):**
* `user_id`: 10234, 59102... (사용자가 늘어날수록 무한 증가)
* `email`: user@example.com (고유 값)
* `client_ip`: 192.168.0.1 (접속자마다 다름)



> [!CAUTION]
> **설계 원칙**
> `User ID`나 `IP Address`와 같이 고유한 식별 정보는 매트릭의 레이블로 사용해서는 안 됩니다. 이러한 정보는 **로그(Log)** 시스템에 기록하고, 매트릭은 시스템의 **거시적인 상태와 추세**를 보는 용도로만 제한해야 합니다.

---

## 6. 해상도(Resolution)와 보관 주기(Retention)

매트릭 데이터는 시간이 지날수록 그 양이 방대해지므로, 효율적인 저장을 위해 해상도와 보관 주기를 전략적으로 설정해야 합니다.

### 6.1. 해상도 (Resolution)

데이터를 얼마나 자주 수집할 것인가에 대한 설정입니다.

* **고해상도 (High Resolution):** 1초 또는 10초 단위 수집. 실시간 디버깅이나 트래픽 스파이크 감지에 유리하나 저장 비용이 높습니다.
* **저해상도 (Low Resolution):** 1분 또는 5분 단위 수집. 장기 추세 분석에 적합하며 비용이 저렴합니다.

### 6.2. 다운샘플링 (Downsampling)

오래된 데이터의 정밀도를 낮추어 보관 비용을 절감하는 기법입니다.

1. **Raw Data:** 10초 단위 수집 (최근 7일 보관)
2. **Roll-up 1:** 1시간 단위 평균값으로 변환 (1개월 보관)
3. **Roll-up 2:** 1일 단위 평균값으로 변환 (1년 보관)

---

## 7. 구글 SRE의 4대 황금 신호 (The Four Golden Signals)

구글 SRE 팀이 제안한, 모니터링 시스템 구축 시 반드시 포함해야 할 4가지 핵심 지표입니다. 대시보드 구성 시 이 4가지 요소를 기본으로 배치하는 것이 좋습니다.

| 시그널 | 정의 | 모니터링 포인트 |
| --- | --- | --- |
| **지연 시간 (Latency)** | 서비스가 요청을 처리하는 데 걸리는 시간 | 성공한 요청과 실패한 요청의 지연 시간을 분리하여 측정해야 합니다. (실패는 주로 매우 빠름) |
| **트래픽 (Traffic)** | 시스템에 발생하는 수요의 양 | 초당 HTTP 요청 수(RPS), 네트워크 대역폭(I/O rate) 등이 포함됩니다. |
| **에러 (Errors)** | 요청 실패 비율 | 명시적 실패(500 에러), 암묵적 실패(200 OK이나 잘못된 콘텐츠), 정책 위반 등을 체크합니다. |
| **포화도 (Saturation)** | 시스템 자원의 한계 도달 정도 | CPU 부하량, 메모리 사용량, 디스크 큐 길이 등을 확인하며, 자원이 꽉 차기 전 경고가 필요합니다. |

---

**Next Step:** 프로메테우스 쿼리 언어(PromQL) 기초 문법 및 데이터 조회 실습
