## Chapter 5. 모니터링 메트릭 해석 및 임계값 설정 가이드

### 5.1. 리소스 측정 단위(Unit)의 기술적 이해

시스템 엔지니어는 모니터링 도구(Prometheus, Grafana)가 데이터를 수집하는 **Raw Unit(원시 단위)**과 대시보드에 표출되는 **Display Unit(표시 단위)**의 차이를 명확히 이해해야 합니다. 특히 메모리와 스토리지 용량 표기에서 **SI 표준(10진수)**과 **IEC 표준(2진수)**의 혼용은 용량 산정의 오차를 발생시키는 주원인입니다.

#### 1. CPU (Processing Power)

CPU 메트릭은 **'시간(Time)'**의 누적값을 **'비율(Rate)'**로 변환하여 표현합니다.

* **Raw Unit (Prometheus):** `Seconds` (Counter 타입). 부팅 이후 CPU가 작업한 총 누적 시간.
* **Display Unit (Grafana/K8s):** `Cores` 또는 `millicores (m)`.
* **1 Core (1000m):** 1초 동안 1개의 vCPU가 100% 가동됨을 의미.
* **Usage vs Load:**
* **Usage (%):** 현재 CPU가 연산을 수행 중인 시간의 비율.
* **Load Average:** 실행 중이거나 실행 대기 중(Run Queue)인 프로세스의 수 + I/O 대기 중인 프로세스의 수.





#### 2. Memory (RAM)

Grafana는 기본적으로 **IEC 60027-2 표준(2진수 접두어)**을 따릅니다.

* **Raw Unit:** `Bytes`.
* **Display Unit:** **KiB, MiB, GiB, TiB**.
* **1 GiB:**  Bytes =  Bytes.
* **주의사항:** 하드웨어 제조사는 10진수(GB)를 사용하므로, 32GB RAM을 장착해도 OS나 Grafana에서는 약 **29.8 GiB**로 표시되는 것이 정상입니다.



#### 3. Disk (Storage & I/O)

디스크 성능 지표는 용량(Capacity), 처리량(Throughput), 응답속도(Latency)의 3차원으로 분석해야 합니다.

* **Throughput:** `Bps` (Bytes per second). 초당 전송 데이터 양.
* **IOPS (I/O Operations Per Second):** 초당 읽기/쓰기 요청 횟수. (Random Access 성능의 핵심 지표)
* **Latency:** `Seconds` -> `ms` (Millisecond). 디스크 컨트롤러가 요청을 처리하고 응답을 줄 때까지 걸리는 시간.

---

### 5.2. 리소스별 상세 임계값(Threshold) 가이드

엔터프라이즈 환경에서 통용되는 리소스 모니터링 기준표입니다. 서비스의 성격(Batch, OLTP, Web)에 따라 임계값은 조정될 수 있으나, 아래 수치는 일반적인 경보(Alerting) 설정의 기준점(Baseline)이 됩니다.

| 리소스 구분 | 세부 메트릭 (Metric) | 표기 단위 (Unit) | 기술적 의미 (Technical Description) | 주의 (Warning) | 위험 (Critical) |
| --- | --- | --- | --- | --- | --- |
| **CPU** | **Usage (User+Sys)** | `%` | CPU 사이클이 Idle 상태가 아닌 비율 | **> 70%** (5분 평균) | **> 90%** (지속 시) |
|  | **Load Average (1m)** | `Integer` | Run Queue 대기 프로세스 수 | **Core 수 × 0.7** | **Core 수 × 1.0** 이상 |
|  | **I/O Wait** | `%` | CPU가 디스크 I/O 완료를 대기하는 시간 | **> 5%** | **> 15%** (디스크 병목) |
|  | **Throttling** | `%` | (컨테이너 환경) CFS Quota 제한에 걸린 비율 | **> 1%** | **> 10%** (Limit 상향 필요) |
| **Memory** | **Utilization** | `%` | `(Total - Available) / Total * 100` | **> 80%** | **> 90%** (OOM 위험) |
|  | **Available** | `GiB` | 실제 할당 가능한 여유 메모리 (Cache 포함) | **< 2 GiB** | **< 500 MiB** |
|  | **Swap Usage** | `%` | 물리 메모리 부족으로 디스크 스왑 사용 비율 | **> 1%** | **> 20%** (성능 급락) |
| **Disk** | **Space Used** | `%` | 파일시스템 사용률 | **> 80%** | **> 90%** |
|  | **Inode Usage** | `%` | 파일 시스템 메타데이터(파일 개수) 사용률 | **> 80%** | **> 90%** (파일 생성 불가) |
|  | **Read/Write Latency** | `ms` | 디스크 I/O 요청 처리에 걸리는 지연 시간 | **> 20ms** | **> 100ms** (서비스 장애) |
| **Network** | **Bandwidth** | `Mbps` | NIC 대역폭 대비 사용량 | **> 70%** | **> 90%** (패킷 드랍 발생) |
|  | **Error/Drop Rate** | `pps` | 초당 패킷 에러 또는 드랍 발생 수 | **> 1** | **> 10** (네트워크 장비 점검) |

---

### 5.3. 핵심 분석 포인트 (System Engineer's View)

#### 1. CPU Load Average의 올바른 해석

CPU 사용률이 50%라도 Load Average가 코어 수보다 높게 나타날 수 있습니다. 이는 **I/O Wait**가 높거나, 프로세스 간의 **Context Switching** 비용이 과다하게 발생하고 있음을 의미합니다. 따라서 모니터링 시 단순히 Usage만 보지 않고, `node_load1` 지표를 CPU 코어 수(`count(node_cpu_seconds_total) by (instance)`)와 비교하여 **Saturation(포화) 지점**을 파악해야 합니다.

#### 2. Memory Available vs Free

리눅스 커널은 유휴 메모리를 적극적으로 **Page Cache**로 활용하여 I/O 성능을 높입니다. 따라서 `Free Memory`가 0에 가까워도 `Available Memory`가 충분하다면 시스템은 정상입니다. 알림(Alert) 설정 시 반드시 `node_memory_MemAvailable_bytes` 지표를 기준으로 삼아야 오탐(False Alarm)을 방지할 수 있습니다.

#### 3. Disk I/O Bottleneck

데이터베이스 서버의 성능 저하는 대부분 CPU가 아닌 디스크 I/O Latency에서 발생합니다. 특히 클라우드 환경(AWS EBS 등)에서는 **IOPS Credit**이 고갈되면 Latency가 급격히 증가(Spike)하므로, `rate(node_disk_io_time_seconds_total)` 메트릭을 통해 디스크가 얼마나 바쁜지(Utilization)를 상시 감시해야 합니다.

---

**Next Step:** 수집된 메트릭을 바탕으로 PromQL(Prometheus Query Language)을 사용하여 `rate()`와 `irate()` 함수를 활용한 실전 쿼리 작성 실습
