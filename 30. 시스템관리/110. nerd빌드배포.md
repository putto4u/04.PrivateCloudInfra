파이썬 설치와 환경 설정의 늪에서 벗어나, 어디서든 즉시 실행 가능한 **FastAPI 컨테이너 환경**을 구축하는 실습 가이드입니다. 이 교재는 `nerdctl`과 `containerd` 환경을 기준으로 작성되었습니다.

---

# 📘 [실습 가이드] FastAPI를 컨테이너로 패키징하기

**목표:** 로컬 파이썬 설치 없이, `nerdctl`을 사용하여 FastAPI 앱을 빌드하고 배포한다.

---

## 1. 사전 준비: 프로젝트 구조 확인

컨테이너 빌드 전, 파일 위치가 정확해야 합니다. 프로젝트 루트 폴더에서 시작하세요.

```text
my_fastapi_project/
├── data/
│   ├── __init__.py
│   └── main.py          <-- FastAPI 코드가 있는 곳
└── Dockerfile           <-- 지금부터 만들 파일

```

---

## 2. Dockerfile 작성 (FastAPI Slim 버전)

`Dockerfile`은 이미지를 만드는 설계도입니다. **`python:3.11-slim`** 이미지를 사용하여 용량을 최소화합니다.

```dockerfile
# 1. 가볍고 최적화된 파이썬 슬림 이미지 선택
FROM python:3.11-slim

# 2. 컨테이너 내부 작업 디렉토리 설정
WORKDIR /app

# 3. 필요한 패키지 설치
# (프로젝트에 의존성이 많다면 requirements.txt를 먼저 COPY하세요)
RUN pip install --no-cache-dir fastapi uvicorn

# 4. 현재 폴더의 모든 소스 코드를 컨테이너로 복사
COPY . .

# 5. 외부 연결을 위한 포트 개방
EXPOSE 8000

# 6. 실행 명령 (data 폴더 안의 main.py 실행)
CMD ["uvicorn", "data.main:app", "--host", "0.0.0.0", "--port", "8000"]

```

---

## 3. 이미지 빌드 및 저장소 업로드 (nerdctl)

`nerdctl`은 `containerd` 기반의 도구로, Docker와 호환되는 명령어를 사용합니다.

### Step 1: 저장소 로그인

이미지를 올릴 레지스트리(Docker Hub 등)에 접속합니다.

```bash
nerdctl login

```

### Step 2: 이미지 빌드

명령어 끝의 마침표(`.`)는 현재 경로의 Dockerfile을 사용한다는 뜻입니다.

```bash
# 형식: nerdctl build -t [사용자계정]/[이미지명]:[태그] .
nerdctl build -t myusername/fastapi-slim-app:v1 .

```

### Step 3: 저장소 푸시 (Push)

빌드된 이미지를 온라인 저장소에 올립니다. 이제 내 컴퓨터에서 파일을 지워도 괜찮습니다.

```bash
nerdctl push myusername/fastapi-slim-app:v1

```

---

## 4. 어디서나 즉시 실행 (Pull & Run)

파이썬이 설치되지 않은 다른 서버나 동료의 컴퓨터에서 다음 명령 한 줄만 입력하면 서버가 뜹니다.

```bash
# 저장소에서 이미지를 내려받아 8000번 포트로 실행
nerdctl run -d -p 8000:8000 --name my-api myusername/fastapi-slim-app:v1

```

> **성공 확인:** 브라우저를 열고 `http://localhost:8000` 또는 `http://localhost:8000/docs`에 접속하여 Swagger UI가 나오는지 확인하세요.

---

## 📝 핵심 요약 노트

| 항목 | 내용 |
| --- | --- |
| **Base Image** | `python:3.11-slim` (가볍고 빠름) |
| **Tool** | `nerdctl` (containerd 기반 제어) |
| **Execution** | `data.main:app` (하위 폴더 구조 대응) |
| **Network** | `--host 0.0.0.0` (컨테이너 외부 접속 허용 필수) |

---

이 교재 내용 중에서 **`requirements.txt`를 활용해 라이브러리를 한꺼번에 관리하는 방법**도 추가해 드릴까요?
