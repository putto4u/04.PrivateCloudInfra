

#  Ingress의 이해와 실전 아키텍처 구현

본 장에서는 쿠버네티스 외부 트래픽 관리의 핵심인 **Ingress(인그레스)**의 동작 원리와 아키텍처를 심도 있게 학습합니다.

단순히 서비스를 외부에 노출하는 것을 넘어, 도메인 기반의 라우팅, 경로(Path) 분기, 그리고 보안을 고려한 **표준 프로덕션 아키텍처**를 설계합니다. 실습은 외부 로드밸런서 연동이 어려운 내부망 환경의 특성을 고려하여, **'내부 접속을 외부 사용자 유입으로 가정'**하는 시뮬레이션 방식으로 진행합니다.

---

### 1. Ingress란 무엇인가?

쿠버네티스 클러스터 내부에는 수십, 수백 개의 애플리케이션(Pod)이 실행됩니다. 이들을 외부 사용자와 연결하기 위해 모든 서비스에 공인 IP를 할당하는 것은 비용과 관리 측면에서 불가능에 가깝습니다.

**Ingress**는 이러한 문제를 해결하는 **'지능형 트래픽 관문'**입니다.

#### **핵심 기능**

* **단일 진입점 (Single Entrypoint):** 하나의 IP와 포트로 모든 외부 트래픽을 수신합니다.
* **L7 라우팅:** 사용자가 요청한 **URL 경로(Path)**나 **도메인(Host)**을 분석하여 적절한 서비스로 연결합니다. (예: `mega.com/shop` → 쇼핑 서비스, `mega.com/blog` → 블로그 서비스)
* **SSL/TLS 종료:** 보안 인증서를 통합 관리하여 HTTPS 통신을 지원합니다.

---

### 2. 프로덕션 수준의 Ingress 아키텍처 설계

실무에서 사용하는 가장 표준적인 네트워크 구성은 **'철저한 역할 분리'**입니다. 우리는 이 원칙에 따라 다음과 같이 아키텍처를 설계합니다.

1. **Ingress Controller (The Gatekeeper):**
* 유일하게 외부에 문을 열고 서 있는 '경비원'입니다.
* 서버의 물리적 포트(80)를 선점하여 모든 트래픽을 1차로 받아냅니다.


2. **ClusterIP Services (The Hidden Apps):**
* 실제 애플리케이션(`front-web`, `view-web`)은 외부와 완전히 차단된 **ClusterIP** 룸에 배치합니다.
* 오직 '경비원(Ingress)'의 안내를 통해서만 접근할 수 있어 보안성이 극대화됩니다.



#### **[실습 시나리오: 가상 외부 접속 환경]**

클라우드 환경(AWS, Azure)에서는 `LoadBalancer`가 공인 IP를 자동으로 할당해줍니다. 하지만 현재 우리의 실습 환경(On-Premise)은 외부 장비의 지원을 받을 수 없습니다.

따라서 우리는 **"Ingress Controller가 설치된 노드의 IP를 외부 공인 IP라고 가정"**하고 아키텍처를 구현합니다.

* **가상 외부 사용자:** 여러분의 PC 브라우저
* **가상 공인 IP:** 마스터 노드의 IP (`192.168.100.251`)
* **트래픽 흐름:** `PC` → `노드 IP (80 Port)` → `Ingress` → `ClusterIP Service` → `Pod`

---

### 3. 인프라 사전 구성 (Prerequisites)

Ingress Controller가 '경비원'으로서 80번 포트를 독점 사용할 수 있도록 환경을 정비합니다.

#### **Step 1: 80번 포트 점유 프로세스 정리**

기존 서버에 웹 서버(Nginx, Apache)가 실행 중이라면 충돌이 발생하므로 중지합니다.

```bash
# 80번 포트 점유 프로세스 중지 및 비활성화
sudo systemctl stop nginx
sudo systemctl disable nginx

```

#### **Step 2: Ingress Controller 진입점 개방**

컨트롤러 서비스에 노드의 IP를 명시적으로 할당(`externalIPs`)하여, 이 IP로 들어오는 80번 트래픽을 수신하도록 설정합니다.

```bash
# 서비스 편집 모드 진입
kubectl edit svc ingress-nginx-controller -n ingress-nginx

```

**[수정 가이드]** `spec` 하위에 `externalIPs`를 추가합니다.

```yaml
spec:
  # (기존 설정 ...)
  type: LoadBalancer
  # [설정] 이 서버의 IP를 외부 접속용 공인 IP로 간주합니다.
  externalIPs:
  - 192.168.100.251

```

---

### 4. 애플리케이션 배포 (Backend Deployment)

보안을 위해 외부 노출이 차단된 **ClusterIP** 타입의 애플리케이션을 배포합니다.

#### **Step 1: 네임스페이스 생성**

```bash
kubectl create namespace megaprod

```

#### **Step 2: 프론트엔드 서비스 (`front-web.yaml`)**

메인 화면을 담당합니다.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: front-web-deploy
  namespace: megaprod
spec:
  replicas: 2
  selector:
    matchLabels:
      app: front-web
  template:
    metadata:
      labels:
        app: front-web
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80
        # 메인 페이지 자동 생성
        command: ["/bin/sh", "-c"]
        args: 
          - echo "<h1 style='color:blue'>WELCOME TO FRONT-END (MAIN)</h1>" > /usr/share/nginx/html/index.html && nginx -g "daemon off;"
---
apiVersion: v1
kind: Service
metadata:
  name: front-web-svc
  namespace: megaprod
spec:
  type: ClusterIP  # [중요] 외부 노출 차단 (내부 전용)
  selector:
    app: front-web
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80

```

#### **Step 3: 리스트 조회 서비스 (`view-web.yaml`)**

`/viewlist` 경로 접속 시 응답할 서비스입니다.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: view-web-deploy
  namespace: megaprod
spec:
  replicas: 2
  selector:
    matchLabels:
      app: view-web
  template:
    metadata:
      labels:
        app: view-web
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80
        command: ["/bin/sh", "-c"]
        args: 
          - echo "<h1 style='color:green'>THIS IS VIEW-LIST PAGE</h1>" > /usr/share/nginx/html/index.html && nginx -g "daemon off;"
---
apiVersion: v1
kind: Service
metadata:
  name: view-web-svc
  namespace: megaprod
spec:
  type: ClusterIP  # [중요] 외부 노출 차단 (내부 전용)
  selector:
    app: view-web
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80

```

---

### 5. 통합 라우팅 규칙 설정 (Ingress Resource)

하나의 '대문'을 통해 들어온 트래픽을 도메인과 경로에 따라 분기하는 규칙을 정의합니다.

#### **통합 인그레스 설정 (`shared-ingress.yaml`)**

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: shared-ingress
  namespace: megaprod
  annotations:
    kubernetes.io/ingress.class: "nginx"
    # [핵심] URL 재작성: 외부의 /viewlist 요청을 내부의 / (루트)로 변경하여 전달
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  ingressClassName: nginx
  rules:
  - host: prod.mega-it.com  # 도메인 접속 규칙
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: front-web-svc
            port:
              number: 80
      - path: /viewlist
        pathType: Prefix
        backend:
          service:
            name: view-web-svc
            port:
              number: 80
  - http: # IP 직접 접속 규칙 (도메인 미지정 시)
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: front-web-svc
            port:
              number: 80

```

---

### 6. 배포 실행 및 검증 (Verification)

#### **Step 1: 리소스 일괄 적용**

```bash
kubectl apply -f front-web.yaml
kubectl apply -f view-web.yaml
kubectl apply -f shared-ingress.yaml

```

#### **Step 2: 접속 테스트 (시뮬레이션)**

이제 우리는 내부망 IP(`192.168.100.251`)를 전 세계에서 접속 가능한 공인 IP라고 가정하고 테스트를 진행합니다.

1. **IP 기반 접속 (기본 라우팅)**
* 브라우저 주소창: `http://192.168.100.251/`
* 결과: **파란색 MAIN 문구** (Default Backend)
* 브라우저 주소창: `http://192.168.100.251/viewlist`
* 결과: **녹색 VIEW-LIST 문구** (Path 라우팅 성공)


2. **도메인 기반 접속 (Host 라우팅)**
* PC의 `hosts` 파일에 `192.168.100.251 prod.mega-it.com` 등록
* 브라우저 주소창: `http://prod.mega-it.com/viewlist`
* 결과: 정상 출력 확인



---

Next Step: Ingress TLS(HTTPS) 인증서 적용 및 보안 설정
