# Module: Blue-Green Deployment Strategy

## 1. 블루-그린 배포(Blue-Green Deployment) 개요

블루-그린 배포는 애플리케이션의 다운타임(Downtime)을 최소화하고, 배포 실패 시 즉각적인 롤백(Rollback)을 보장하기 위한 무중단 배포 전략 중 하나이다. 이 방식은 물리적으로 또는 논리적으로 완벽하게 분리된 두 개의 프로덕션 환경(Blue와 Green)을 유지하는 것을 핵심으로 한다.

### 1.1 핵심 개념

* **Blue 환경:** 현재 라이브 트래픽을 처리하고 있는 구버전(Stable) 운영 환경.
* **Green 환경:** 새 버전(New Release)이 배포되어 테스트 대기 중인 격리된 환경.
* **트래픽 스위칭(Traffic Switching):** 로드밸런서(Load Balancer)나 DNS 설정을 변경하여 사용자 트래픽을 순식간에 Blue에서 Green으로 전환하는 과정.

### 1.2 배포 프로세스 (Workflow)

1. **초기 상태:** 모든 트래픽은 **Blue** 환경(v1.0)으로 향한다. **Green** 환경은 유휴(Idle) 상태이거나 존재하지 않는다.
2. **배포 및 테스트:** **Green** 환경에 새로운 버전(v2.0)을 배포한다. 이때 실제 운영 데이터베이스와 연결하거나, 스테이징 데이터를 통해 기능 및 성능 테스트를 수행한다.
3. **트래픽 전환 (Cutover):** 테스트가 완료되면 로드밸런서의 타겟 그룹을 변경하거나 라우팅 규칙을 수정하여 모든 트래픽을 **Green** 환경으로 돌린다.
4. **모니터링:** 전환 직후 오류율, 지연 시간(Latency) 등을 집중 모니터링한다.
5. **종료 또는 롤백:**
* **성공 시:** **Blue** 환경의 리소스를 제거하여 비용을 절감하거나, 다음 배포를 위한 대기 상태(Staging)로 전환한다.
* **실패 시:** 트래픽을 즉시 다시 **Blue** 환경으로 원복(Rollback)한다.



---

## 2. 장점과 단점 (Trade-offs)

IT 아키텍트로서 배포 전략 선정 시 고려해야 할 요소는 가용성 비용과 운영 복잡도이다.

### 2.1 장점 (Pros)

* **즉각적인 롤백 (Instant Rollback):** 배포 후 치명적인 버그가 발견되더라도, 라우팅만 다시 구버전(Blue)으로 돌리면 되므로 복구 시간이 수 초 이내로 단축된다.
* **테스트 환경의 신뢰성:** 실제 운영 환경과 동일한 인프라(Green)에서 최종 테스트를 수행할 수 있어, '스테이징에서는 되는데 운영에서는 안 되는' 문제를 방지한다.
* **무중단 배포:** 사용자는 서비스 중단을 거의 느끼지 못한다(로드밸런서의 Connection Draining 설정에 따라 다름).

### 2.2 단점 (Cons)

* **비용 증가 (Double Resource Cost):** 배포가 진행되는 동안 두 배의 인프라 리소스(서버, 컨테이너 등)가 필요하다. 클라우드 환경에서는 사용한 시간만큼만 과금되므로 비교적 부담이 적지만, 온프레미스 환경에서는 유휴 자원 낭비가 심할 수 있다.
* **데이터베이스 동기화의 복잡성:** 애플리케이션은 stateless하게 관리가 가능하지만, 데이터베이스는 stateful하다. 두 버전의 앱이 동일한 DB를 바라볼 때 스키마 변경(Schema Migration)이 발생하면 호환성 문제가 생길 수 있다.
* **콜드 스타트(Cold Start):** Green 환경으로 트래픽이 한꺼번에 몰릴 경우, 캐시(Cache)가 예열(Warm-up)되지 않아 초기 성능 저하가 발생할 수 있다.

---

## 3. 데이터베이스 처리 전략 (Database Migration Strategy)

블루-그린 배포에서 가장 까다로운 부분은 DB 스키마 변경이다. **하위 호환성(Backward Compatibility)** 유지가 필수적이다.

### 3.1 공유 데이터베이스 (Shared Database) 패턴

대부분의 경우 Blue와 Green은 동일한 물리적 DB를 공유한다.

* **원칙:** DB 스키마 변경은 애플리케이션 배포와 분리하여 선행되어야 한다.
* **절차 예시 (컬럼 명 변경 시):**
1. 기존 컬럼(`old_col`)과 새 컬럼(`new_col`)을 모두 가진 상태로 스키마를 변경한다.
2. 애플리케이션(Green)은 두 컬럼 모두에 데이터를 쓰도록 로직을 작성한다.
3. 배포 후 데이터 마이그레이션을 수행한다.
4. 다음 배포 때 `old_col` 참조 코드를 삭제한다.



### 3.2 분리 데이터베이스 패턴

Blue용 DB와 Green용 DB를 별도로 두는 방식이다.

* 읽기 전용(Read Replica)을 활용하거나 양방향 동기화가 필요하므로 구성 난이도가 매우 높고 데이터 정합성 이슈가 발생할 수 있어 특수한 경우(대규모 마이그레이션 등)에만 사용한다.

---

## 4. 실전 구현: AWS 및 Kubernetes

### 4.1 AWS 환경에서의 구현

AWS는 관리형 서비스를 통해 블루-그린 배포를 손쉽게 구현할 수 있다.

* **EC2 & ELB (Elastic Load Balancer):**
* Target Group을 Blue용과 Green용으로 생성.
* Auto Scaling Group을 두 개로 분리하여 새 버전 인스턴스를 생성.
* ELB 리스너 규칙을 수정하여 트래픽을 새 Target Group으로 전환.


* **Route 53 (Weighted Routing):**
* DNS 레벨에서 가중치 기반 라우팅을 사용하여 트래픽을 서서히 이동(Canary와 유사)하거나 한 번에 전환.


* **AWS CodeDeploy:**
* `BLUE_GREEN` 배포 옵션을 기본 지원하며, 트래픽 전환 및 롤백 자동화를 제공한다.
* **[비용 주의]** 배포가 진행되는 동안 EC2 인스턴스 수가 2배가 되므로, 해당 시간 동안 컴퓨팅 비용이 2배로 청구된다. RDS의 경우 Multi-AZ나 Read Replica 활용 시 추가 비용이 발생한다.



### 4.2 Kubernetes(K8s) 환경에서의 구현

Kubernetes는 Pod와 Service 리소스를 활용하여 유연하게 구현한다.

* **Service Selector 변경 방식:**
1. `Deployment-v1` (Label: `version: v1`)이 실행 중.
2. `Deployment-v2` (Label: `version: v2`)를 배포하고 Health Check 통과 대기.
3. `Service`의 Selector를 `version: v1`에서 `version: v2`로 수정 (`kubectl patch service`).


* **Ingress Controller 활용:**
* Nginx Ingress나 AWS ALB Ingress Controller 등을 사용하여 특정 헤더나 가중치에 따라 트래픽을 분기.


* **ArgoCD Rollouts:**
* 기본 K8s Deployment 객체 대신 `Rollout` CRD를 사용하여 블루-그린 배포 전략을 명시적으로 선언하고 자동화할 수 있다.



---

## 5. Summary & Checklist

| 구분 | 체크리스트 |
| --- | --- |
| **인프라** | 배포 시 순간적으로 2배의 리소스를 감당할 수 있는 쿼터(Quota)와 예산이 확보되었는가? |
| **데이터** | DB 스키마 변경이 구버전 애플리케이션(Blue)과 호환되는가? (하위 호환성) |
| **세션** | 사용자 세션(Session)이 분산 저장소(Redis 등)에 저장되어 있어 트래픽 전환 시 로그아웃되지 않는가? |
| **롤백** | 배포 실패 시 즉시 Blue 환경으로 되돌릴 수 있는 자동화 스크립트나 절차가 준비되었는가? |

**결론:** 블루-그린 배포는 **"안정성"**을 최우선으로 하는 미션 크리티컬한 서비스에 적합한 전략이다. 하지만 리소스 비용과 DB 관리의 복잡성을 동반하므로, 단순한 서비스라면 롤링 배포(Rolling Update)가 더 효율적일 수 있음을 인지해야 한다.

Next Step: 카나리(Canary) 배포와 롤링(Rolling) 배포의 차이점 및 전략 비교
