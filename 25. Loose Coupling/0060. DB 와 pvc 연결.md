이제 준비된 **3개의 그릇(PVC)**에 **3개의 엔진(MySQL Pod)**을 각각 정확하게 연결하여 가동할 차례입니다.

이 작업은 앞서 만든 `mysql-storage.yaml`의 PVC 이름과 `mysql-deploy.yaml`의 볼륨 마운트 설정을 일대일로 매칭하는 과정입니다. 강사님께서 강조하신 **느슨한 결합**의 실체를 확인하는 가장 중요한 단계이기도 합니다.

---

## MySQL 엔진과 영구 저장소(PVC) 연결 및 배포

### 1. 연결 구조도

동일한 네임스페이스 내에서 각 Deployment가 자신에게 할당된 PVC를 호출하여 컨테이너 내부의 `/var/lib/mysql` 경로에 연결합니다.

| 서비스 역할 | 배포 이름 (Deployment) | 연결될 PVC 이름 | 컨테이너 내부 경로 |
| --- | --- | --- | --- |
| **쓰기 전용 (Primary)** | `mysql-primary` | `mysql-pvc-primary` | `/var/lib/mysql` |
| **읽기 전용 1 (Replica)** | `mysql-replica-1` | `mysql-pvc-replica-1` | `/var/lib/mysql` |
| **읽기 전용 2 (Replica)** | `mysql-replica-2` | `mysql-pvc-replica-2` | `/var/lib/mysql` |

---

### 2. 통합 배포 정의 (`mysql-full-stack.yaml`)

각 배포 파일에 PVC를 명확히 매핑하여 주석과 함께 구성했습니다.

```yaml
# mysql-full-stack.yaml
# --- 1. 쓰기 전용 Primary 서버 (1개) ---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql-primary
  namespace: wb_prod
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mysql
      role: primary
  template:
    metadata:
      labels:
        app: mysql
        role: primary
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: "12345678"
        - name: MYSQL_USER
          value: "admin"
        - name: MYSQL_PASSWORD
          value: "12345678"
        volumeMounts:
        - name: mysql-data
          mountPath: /var/lib/mysql  # MySQL 데이터 실제 저장 경로
      volumes:
      - name: mysql-data
        persistentVolumeClaim:
          claimName: mysql-pvc-primary # 준비된 Primary용 PVC 연결

---
# --- 2. 읽기 전용 Replica-1 서버 (1개) ---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql-replica-1
  namespace: wb_prod
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mysql
      role: replica-1
  template:
    metadata:
      labels:
        app: mysql
        role: replica-1
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: "12345678"
        volumeMounts:
        - name: mysql-data
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-data
        persistentVolumeClaim:
          claimName: mysql-pvc-replica-1 # Replica-1 전용 PVC 연결

---
# --- 3. 읽기 전용 Replica-2 서버 (1개) ---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql-replica-2
  namespace: wb_prod
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mysql
      role: replica-2
  template:
    metadata:
      labels:
        app: mysql
        role: replica-2
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: "12345678"
        volumeMounts:
        - name: mysql-data
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-data
        persistentVolumeClaim:
          claimName: mysql-pvc-replica-2 # Replica-2 전용 PVC 연결

```

---

### 3. 설치 및 연결 확인 방법

**단계 1: 설정 적용**

```bash
kubectl apply -f mysql-full-stack.yaml

```

**단계 2: PVC 바인딩 확인**
포드가 생성되면서 `Pending`이었던 PVC들이 `Bound` 상태로 변했는지 확인합니다.

```bash
kubectl get pvc -n wb_prod

```

**단계 3: 물리 경로 매핑 확인 (워커 노드)**
워커 노드에 접속하여 실제로 3개의 독립된 폴더가 생성되었는지 확인합니다.

```bash
ls -l /opt/local-path-provisioner/

```

---

### 4. 핵심 관리 포인트

* **데이터 격리**: 3개의 포드는 동일한 MySQL 이미지를 쓰지만, 각각 연결된 PVC가 다르기 때문에 서로의 데이터를 절대 간섭할 수 없습니다.
* **노드 고정 효과**: Local Path Provisioner는 포드가 한 번 배정된 노드를 기억합니다. 포드가 죽었다 살아나도 쿠버네티스는 해당 데이터가 있는 노드로 포드를 다시 보냅니다.
* **관리 효율**: `mysql-replica-1`을 수정해도 `primary`나 `replica-2`에는 아무런 영향이 없는 독립적인 운영이 가능합니다.

> [!IMPORTANT]
> **과금 및 자원 안내**:
> 3개의 독립적인 로컬 스토리지를 사용하므로 **추가 클라우드 과금은 없습니다.** 다만, MySQL 인스턴스 3개가 동시에 가동되므로 워커 노드의 가용 메모리가 충분한지(`free -m`) 다시 한번 점검하십시오.

---

Next Step: **쓰기 서비스(mysql-write)와 읽기 서비스(mysql-read)를 분리하여 트래픽 라우팅하기**

---

Next Step: **back-pvc**
