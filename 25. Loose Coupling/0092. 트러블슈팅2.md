## [실전 트러블슈팅 2] 구성 요소 정합성 및 절차 완전성 3단계 검증

본 챕터는 프로젝트의 모든 리소스(YAML)와 실행 절차를 **세 번 반복(Triple Check)** 하여, 실제 구축 시 발생할 수 있는 '이름 불일치', '순서 오류', '설정 누락'을 사전에 차단하는 최종 점검 리스트입니다.

---

### 1단계: 이름 및 레이블(Label) 정합성 크로스 체크

YAML 파일 간의 연결 고리가 되는 **이름(Name)**과 **레이블(Label)**, **셀렉터(Selector)**가 정확히 일치하는지 확인합니다. 단 하나라도 틀리면 연결이 거부됩니다.

#### [Check 1-1] 서비스(Service)와 포드(Pod)의 연결 고리

서비스가 포드를 찾지 못하면 엔드포인트(Endpoints)가 생성되지 않습니다.

| 구분 | Service Selector (찾는 값) | Deployment Label (가지고 있는 값) | 일치 여부 |
| --- | --- | --- | --- |
| **쓰기 DB** | `role: primary` | `role: primary` | ✅ 확인 필수 |
| **읽기 DB** | `role: replica` | `role: replica` | ✅ 확인 필수 |
| **FastAPI** | `app: fastapi` | `app: fastapi` | ✅ 확인 필수 |
| **Python** | `app: py-web` | `app: py-web` | ✅ 확인 필수 |

> **주의**: 읽기 로드밸런싱 확장 시(`mysql-read-enhanced.yaml`), Service가 `app: mysql`을 찾도록 변경했다면, **모든 DB 포드(Primary 포함)**에 `app: mysql` 레이블이 공통으로 붙어 있어야 합니다.

#### [Check 1-2] PVC와 Deployment의 볼륨 매핑

배포 파일에서 PVC 이름을 잘못 적으면 포드가 `Pending` 상태에서 멈춥니다.

| 역할 | Deployment 내 `claimName` | 실제 생성된 PVC 이름 (`metadata.name`) |
| --- | --- | --- |
| **Primary** | `mysql-pvc-primary` | `mysql-pvc-primary` |
| **Replica-1** | `mysql-pvc-replica-1` | `mysql-pvc-replica-1` |
| **Replica-2** | `mysql-pvc-replica-2` | `mysql-pvc-replica-2` |

---

### 2단계: 논리적 실행 순서 및 누락 절차 검증

절차가 뒤바뀌면 에러가 발생합니다. 올바른 순서대로 진행되는지 시뮬레이션합니다.

#### [Check 2-1] DB 기동 전 스토리지 준비 (Pre-condition)

* **오류 시나리오**: `mysql-deploy.yaml`을 먼저 실행하고 나중에 `mysql-pvc.yaml`을 실행함.
* **증상**: 포드가 "PersistentVolumeClaim not found" 에러를 뱉으며 무한 재시작.
* **검증**: `kubectl get pvc` 명령어로 상태가 `Bound`(또는 Pending)인지 확인 후 DB를 배포해야 합니다.

#### [Check 2-2] Server-ID 설정 누락 (Critical)

* **오류 시나리오**: Docker Hub의 기본 MySQL 이미지를 그대로 사용하여 배포함.
* **증상**: 모든 MySQL의 `server-id`가 `1`이 되어 복제 연결 시 `Fatal error` 발생.
* **검증**: Deployment YAML의 `args` 항목에 각각 `--server-id=1`, `--server-id=11`, `--server-id=12`가 명시되었는지 **반드시 확인**해야 합니다. (이전 챕터에서 가장 놓치기 쉬운 부분입니다.)

#### [Check 2-3] 데이터 복원 시점 (Timing)

* **오류 시나리오**: 데이터를 먼저 붓고 나서 복제(Replication)를 연결함.
* **증상**: Primary에는 데이터가 있는데 Replica는 텅 비어있음.
* **검증**:
1. 빈 DB 상태에서 Primary-Replica 연결 (`CHANGE MASTER TO...`)
2. `START SLAVE`
3. 그 후에 `employees.sql` 임포트 수행



---

### 3단계: 애플리케이션 코드와 인프라 설정 일치 여부

소스 코드(Python/FastAPI) 내에 하드코딩된 설정이 실제 인프라 환경과 맞는지 확인합니다.

#### [Check 3-1] DB 접속 호스트명 (DNS)

코드 내의 접속 정보가 쿠버네티스 서비스 이름과 정확히 일치해야 합니다.

* **코드**: `host="mysql-write"` ↔ **K8s Service**: `metadata.name: mysql-write`
* **코드**: `host="mysql-read"` ↔ **K8s Service**: `metadata.name: mysql-read`

#### [Check 3-2] 인그레스 경로와 애플리케이션 라우팅 (Rewrite)

인그레스의 `rewrite-target` 설정이 없으면 경로 에러(404)가 발생합니다.

* **Ingress 설정**: `path: /bucket`, `rewrite-target: /`
* **요청 흐름**: 클라이언트(`http://IP/bucket/users`) → Ingress(경로 자름) → FastAPI(`http://Service/users`)
* **검증**: 만약 `rewrite-target` 옵션이 빠져 있다면, FastAPI 코드를 수정하여 `@app.get("/bucket/users")`처럼 경로를 맞춰주거나 어노테이션을 꼭 넣어야 합니다. (본 교재는 어노테이션 사용을 기준으로 작성됨)

#### [Check 3-3] 계정 정보 불일치

* **DB 생성 시**: `MYSQL_USER: admin`, `MYSQL_PASSWORD: 12345678`
* **앱 코드**: `user="admin"`, `password="12345678"`
* **복제 설정 시**: `repl_user` (복제 전용 계정이므로 앱 코드와 달라도 됨. 혼동 주의)

---

### 최종 승인 및 배포 승인 (Ready to Launch)
