## MySQL Master-Slave 실시간 데이터 동기화(Replication) 구축

쓰기 전용 서버(Primary)의 변경 사항을 읽기 전용 서버(Replica)들이 실시간으로 복제하도록 설정합니다. 이 과정을 통해 데이터의 안정성을 확보하고, 읽기 부하를 완벽하게 분산할 수 있습니다.

---

### 1. 데이터 동기화(Replication) 작동 원리

MySQL의 복제는 **Binary Log(Binlog)**를 기반으로 움직입니다.

1. **Primary**: 모든 변경 사항(INSERT, UPDATE 등)을 Binary Log에 기록합니다.
2. **Replica**: Primary의 Binary Log를 읽어와 자신의 **Relay Log**에 저장한 뒤 실행하여 데이터를 동기화합니다.

---

### 2. Primary 서버 설정 및 복제 계정 생성

Primary 서버는 로그를 남기도록 설정하고, Replica 서버가 접속할 수 있는 전용 복제 계정을 만들어야 합니다.

**단계 1: Primary 설정 파일 수정 (이미 배포된 경우 환경 변수로 대체 가능)**
현재 우리 예제에서는 `kubectl exec`를 통해 Primary 내부에서 복제용 계정을 생성합니다.

```bash
# Primary 포드 접속
kubectl exec -it mysql-primary-xxxx -n wb_prod -- mysql -u root -p12345678

# 1. 복제 전용 사용자 생성 (모든 IP에서 접속 허용)
CREATE USER 'repl_user'@'%' IDENTIFIED WITH mysql_native_password BY 'repl_password';

# 2. 복제 권한 부여
GRANT REPLICATION SLAVE ON *.* TO 'repl_user'@'%';
FLUSH PRIVILEGES;

# 3. Primary의 현재 로그 파일명과 위치(Position) 확인 (매우 중요)
SHOW MASTER STATUS;

```

> **주의**: `SHOW MASTER STATUS;` 결과로 나온 `File` 이름(예: `binlog.000001`)과 `Position` 번호(예: `157`)를 반드시 메모해 두어야 합니다.

---

### 3. Replica 서버 동기화 설정 (`mysql-read` 서비스 활용)

이제 각 읽기 전용 서버가 Primary 서버를 바라보도록 설정합니다.

**단계 1: Replica 1번 서버 설정**

```bash
# Replica-1 포드 접속
kubectl exec -it mysql-replica-1-xxxx -n wb_prod -- mysql -u root -p12345678

# 1. 동기화 대상 설정 (주소는 서비스 명인 mysql-write 사용)
CHANGE MASTER TO 
  MASTER_HOST='mysql-write',
  MASTER_USER='repl_user',
  MASTER_PASSWORD='repl_password',
  MASTER_LOG_FILE='binlog.000001',  # Primary에서 확인한 파일명
  MASTER_LOG_POS=157;               # Primary에서 확인한 포지션 번호

# 2. 복제 프로세스 시작
START SLAVE;

# 3. 상태 확인
SHOW SLAVE STATUS\G

```

> **확인 포인트**: `Slave_IO_Running`과 `Slave_SQL_Running` 항목이 모두 `Yes`여야 합니다. (Replica 2번 서버도 동일하게 반복합니다.)

---

### 4. 동기화 검증 테스트

실제로 쓰기 서버에서 데이터를 넣었을 때 읽기 서버에 나타나는지 확인합니다.

**단계 1: Primary에서 데이터 입력**

```bash
kubectl exec -it mysql-primary-xxxx -n wb_prod -- mysql -u admin -p12345678 -e "CREATE TABLE employees.sync_test (id INT, val VARCHAR(10)); INSERT INTO employees.sync_test VALUES (1, 'K8S_TEST');"

```

**단계 2: Replica(로드밸런서)에서 데이터 조회**

```bash
# 읽기 전용 서비스(mysql-read)를 통해 조회
kubectl exec -it mysql-test -- mysql -h mysql-read -u admin -p12345678 -e "SELECT * FROM employees.sync_test;"

```

---

### 5. 핵심 관리 포인트 (주석 및 주의사항)

* **Server ID**: 실무에서는 각 서버의 `server-id`가 겹치지 않아야 합니다. (현재 공식 이미지는 기본값이 다르거나 설정을 통해 부여해야 함)
* **네트워크 통신**: `MASTER_HOST`를 `mysql-write` 서비스 이름으로 지정함으로써, 포드 IP가 바뀌어도 자동으로 연결을 유지하는 **느슨한 결합**을 완성했습니다.
* **데이터 일관성**: 읽기 전용 서버에서는 `SET GLOBAL read_only = 1;` 명령을 통해 강제로 쓰기를 막아 데이터 꼬임을 방지할 수 있습니다.

> [!IMPORTANT]
> **과금 관련 안내**:
> 복제 과정에서 발생하는 내부 트래픽은 **AWS 데이터 전송 비용을 발생시키지 않습니다.** 다만, 빈번한 동기화는 워커 노드의 CPU 사용량을 높일 수 있으므로 주의하십시오.

---

Next Step: **복제 상태를 모니터링하고 지연 시간(Lag)을 확인하는 대시보드 구성**

---

Next Step: **back-pvc**
