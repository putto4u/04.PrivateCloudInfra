강사님, 전체 프로세스를 시뮬레이션해 본 결과, 실습 현장에서 수강생들이 **100% 에러를 겪거나 실습이 멈출 수 있는 치명적인 논리적 구멍 3가지**를 발견했습니다.

이 부분은 반드시 교재에 수정 반영되어야 합니다. 그렇지 않으면 "복제 구성이 안 됩니다", "슬레이브가 안 붙습니다"라는 질문이 쏟아질 것입니다.

---

## [긴급 점검] 프로젝트 치명적 오류 수정 및 보완 가이드

완벽한 실습을 위해 다음 3가지 항목을 기존 교재 내용에 반드시 업데이트해야 합니다.

### 1. MySQL Server-ID 중복 문제 (가장 치명적)

* **현상**: 현재 배포(Deployment) 설정대로라면 모든 MySQL 컨테이너의 `server-id`가 기본값(`1`)으로 동일하게 설정됩니다.
* **결과**: MySQL 복제(Replication)는 서로 다른 `server-id`를 가져야만 작동합니다. ID가 같으면 복제 연결이 즉시 끊어지고 무한 재접속 에러가 발생합니다.
* **해결책**: 각 배포(Deployment) YAML의 `args` 항목에 고유한 서버 ID를 명시해야 합니다.

**[수정된 YAML 예시]**

```yaml
# Primary 배포 설정 중
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        args: ["--server-id=1"]  # Primary는 1번

# Replica-1 배포 설정 중
        args: ["--server-id=11"] # Replica-1은 11번

# Replica-2 배포 설정 중
        args: ["--server-id=12"] # Replica-2는 12번

```

### 2. 데이터 동기화 순서의 오류 (논리적 결함)

* **현상**: 기존 절차는 **[데이터 복원] → [복제 설정]** 순서였습니다.
* **결과**: 복제 설정을 하기 전에 Primary에 데이터를 부으면, 그 데이터는 Binary Log에 기록되지 않거나, Replica가 연결되기 전이라 전파되지 않습니다. 결과적으로 Replica는 텅 빈 상태가 됩니다.
* **해결책**: 절차를 **[복제 설정(빈 DB끼리 연결)] → [데이터 복원(Primary에 붓기)]** 순서로 바꿔야 합니다. 그래야 붓는 과정이 실시간으로 Replica로 넘어갑니다.

### 3. Ingress와 MetalLB의 관계 (사전 조건 누락)

* **현상**: 인그레스 설정에 `host: 192.168.0.251`을 넣었지만, 실제로 쿠버네티스 클러스터가 이 IP를 Ingress Controller에 할당해 주지 않으면 접속이 불가능합니다.
* **결과**: 브라우저에서 무한 로딩이 걸립니다.
* **해결책**: 실습 환경에 **MetalLB**가 설치되어 있고, `192.168.0.251`이 할당 가능한 대역인지 확인하는 "사전 점검(Pre-flight Check)" 단계를 넣어야 합니다.

---

## [수정된] 전체 프로젝트 진행 절차 (Re-ordered)

위의 오류를 바로잡아, 실패 없는 논리적 순서로 재구성한 로드맵입니다.

### Phase 1: 인프라 기반 구축

1. **네트워크 점검**: MetalLB 및 Ingress Controller 활성화 확인 (`192.168.0.251` 할당 확인)
2. **스토리지 준비**: Local Path Provisioner 설치 확인 및 `StorageClass` 점검
3. **그릇 만들기**: `mysql-pvc.yaml` 배포 (Primary, Replica1, Replica2용 3개)

### Phase 2: DB 클러스터 구축 (수정됨)

4. **DB 엔진 배포**: `server-id`가 지정된 `mysql-deploy.yaml` 배포
5. **서비스 노출**: `mysql-write` 및 `mysql-read` 서비스 생성
6. **[중요] 복제 연결 (Replication Setup)**:
* 빈 DB 상태에서 Primary 유저 생성
* 빈 DB 상태에서 Replica들이 Primary를 바라보게 설정 (`CHANGE MASTER TO...`)
* `SHOW SLAVE STATUS`로 연결 성공 확인



### Phase 3: 데이터 마이그레이션 (순서 변경됨)

7. **데이터 복원**:
* 이제 Primary에 `employees.sql`을 붓습니다.
* **확인**: Replica 서버에서도 테이블과 데이터가 실시간으로 생기는지 확인합니다. (이것이 진정한 복제 테스트입니다.)



### Phase 4: 애플리케이션 배포 및 통합

8. **백엔드 배포**: FastAPI 및 Python Web 배포 (서비스 이름으로 DB 연결)
9. **인그레스 적용**: 외부 접속 경로(`/`, `/vew`, `/bucket`) 라우팅 설정
10. **최종 부하 테스트**: 읽기 로드밸런싱 동작 검증

---

### [부록] 트러블 슈팅 체크리스트 (에러 사전 방지)

실습 중 에러가 발생할 확률이 가장 높은 곳들을 미리 점검합니다.

* **Q: Replica의 `Slave_IO_Running`이 `Connecting`에서 멈춰요.**
* **A**: Primary와 Replica의 `server-id`가 같은지 확인하세요. (`SELECT @@server_id;`로 확인)
* **A**: 네트워크 정책이나 방화벽이 3306 포트를 막고 있는지, 서비스 이름(`mysql-write`) 오타가 없는지 확인하세요.


* **Q: 데이터를 부었는데 Replica에 없어요.**
* **A**: 복제(Start Slave)를 하기 전에 데이터를 먼저 부었기 때문입니다. 데이터를 지우고 복제 연결 후 다시 붓거나, `mysqldump`를 떠서 Replica에 수동으로 넣어줘야 합니다.


* **Q: 브라우저 접속이 안 돼요 (404 Not Found).**
* **A**: Ingress YAML에 `rewrite-target` 어노테이션이 있는지 확인하세요. `/bucket`으로 들어온 요청을 앱에는 `/`로 전달해야 앱이 경로를 인식합니다.



---

Next Step: **back-pvc**
