## MySQL 아키텍처: 읽기 전용 로드밸런서 구축 및 서비스 통합

데이터베이스 시스템의 성능과 안정성을 극대화하기 위해 **접속 창구(Service)**와 **데이터 처리 엔진(Pod)**, 그리고 **저장소(PVC)**를 각각 독립적으로 구성합니다. 특히 읽기 작업이 많은 서비스 특성을 고려하여, 2대의 레플리카 서버를 하나의 로드밸런서로 묶어 트래픽을 분산하는 구조를 완성합니다.

---

### 1. 서비스 및 엔진 통합 정의 (`mysql-svc-deploy.yaml`)

쓰기 전용(Primary)과 읽기 전용(Replica) 서비스의 엔드포인트를 분리하고, 각 엔진이 전용 PVC를 점유하도록 설정합니다.

```yaml
# mysql-svc-deploy.yaml
# --- [접속층] 읽기 전용 로드밸런서 서비스 ---
apiVersion: v1
kind: Service
metadata:
  name: mysql-read
  namespace: wb_prod
spec:
  ports:
    - port: 3306
      targetPort: 3306
  selector:
    app: mysql
    role: replica    # 'role: replica' 레이블을 가진 모든 포드로 트래픽 분산
---
# --- [연산층] 읽기 전용 엔진 1 (Replica-1) ---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql-replica-1
  namespace: wb_prod
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mysql
      role: replica
      instance: replica-1
  template:
    metadata:
      labels:
        app: mysql
        role: replica # 서비스 로드밸런싱 그룹에 포함
        instance: replica-1
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: "12345678"
        volumeMounts:
        - name: db-vol
          mountPath: /var/lib/mysql
      volumes:
      - name: db-vol
        persistentVolumeClaim:
          claimName: mysql-pvc-replica-1 # [저장층] 전용 PVC 연결
---
# --- [연산층] 읽기 전용 엔진 2 (Replica-2) ---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql-replica-2
  namespace: wb_prod
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mysql
      role: replica
      instance: replica-2
  template:
    metadata:
      labels:
        app: mysql
        role: replica
        instance: replica-2
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: "12345678"
        volumeMounts:
        - name: db-vol
          mountPath: /var/lib/mysql
      volumes:
      - name: db-vol
        persistentVolumeClaim:
          claimName: mysql-pvc-replica-2

```

---

### 2. 실행 방법

작성된 통합 설정 파일을 클러스터에 적용하여 전체 레이어를 기동합니다.

```bash
# 1. 통합 설정 적용
kubectl apply -f mysql-svc-deploy.yaml

# 2. 모든 자원의 배포 상태 확인
kubectl get all -n wb_prod -l app=mysql

```

---

### 3. 확인 및 테스트 방법

구축된 로드밸런서가 실제 2대의 레플리카 서버로 트래픽을 나누어 주는지 검증합니다.

**단계 1: 서비스 엔드포인트 확인**
`mysql-read` 서비스가 2개의 포드 IP를 모두 인식하고 있는지 확인합니다.

```bash
# Endpoints 항목에 2개의 IP 주소가 나열되어야 합니다.
kubectl get endpoints mysql-read -n wb_prod

```

**단계 2: 부하 분산(Load Balancing) 테스트**
임시 테스트 포드를 띄워 `mysql-read` 주소로 접속을 반복 시도합니다. 매번 응답하는 호스트명이 달라진다면 로드밸런싱이 정상 작동하는 것입니다.

```bash
# 3회 반복 실행하며 응답하는 포드 이름(@@hostname) 확인
for i in {1..3}; do
  kubectl run mysql-test-$i --image=mysql:8.0 -it --rm -n wb_prod -- \
  mysql -h mysql-read -u admin -p12345678 -e "select @@hostname;"
done

```

---

### 4. 핵심 관리 포인트

* **구조적 분리**: 접속(Service), 연산(Pod), 저장(PVC)이 서로 이름으로만 연결되는 **느슨한 결합**을 유지하여 유지보수성을 극대화했습니다.
* **고가용성**: 특정 레플리카 포드에 장애가 발생하더라도 서비스(`mysql-read`)는 살아있는 다른 포드로 즉시 트래픽을 우회시킵니다.
* **유연한 확장**: 읽기 부하가 늘어날 경우 `Deployment`의 `replicas` 수만 늘리면 인그레스나 서비스 설정 변경 없이 즉시 성능 확장이 가능합니다.

> [!IMPORTANT]
> **과금 및 자원 안내**:
> 본 구성은 클러스터 내부 자원을 활용하는 **ClusterIP** 기반 로드밸런싱이므로 **추가적인 클라우드 비용이 발생하지 않습니다.** 단, 다수의 DB 인스턴스 실행에 따른 워커 노드의 CPU/Memory 가용량을 상시 모니터링하십시오.

---

Next Step: **Primary(쓰기)와 Replica(읽기) 간의 실시간 데이터 동기화(Replication) 설정**

---

Next Step: **back-pvc**
