## FastAPI 백엔드 서버와 MySQL 클러스터 연동 및 통합 구축

데이터베이스 클러스터(Primary & Replicas)와 영구 저장소(PVC)가 모두 준비되었습니다. 이제 백엔드 서버인 **FastAPI**를 배포하고, 서비스 이름(DNS)을 통해 읽기/쓰기 요청을 분리하여 처리하는 **느슨한 결합**의 최종 단계를 실습합니다.

---

### 1. 서비스 연동 아키텍처 및 전략

FastAPI 애플리케이션은 인프라에서 제공하는 두 개의 창구(Service)를 용도에 맞게 호출합니다.

* **쓰기 전용 창구 (`mysql-write`)**: 오직 Primary 서버로만 연결되어 데이터 생성 및 수정을 담당합니다.
* **읽기 전용 창구 (`mysql-read`)**: Primary를 포함하여 총 3대의 서버가 참여하는 로드밸런서로, 조회 요청을 분산 처리합니다.

---

### 2. FastAPI 배포 정의 (`fastapi-deployment.yaml`)

애플리케이션 코드 내부에 IP가 아닌 **서비스 호스트명**을 사용하여 인프라 변화에 유연하게 대응하도록 구성합니다.

```yaml
# fastapi-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: fastapi-web
  namespace: wb_prod
spec:
  replicas: 2 # 고가용성을 위해 백엔드 서버 2대 가동
  selector:
    matchLabels:
      app: fastapi
  template:
    metadata:
      labels:
        app: fastapi
    spec:
      containers:
      - name: fastapi-container
        image: python:3.9-slim
        command: ["/bin/sh", "-c"]
        args:
          - |
            # 1. 필수 라이브러리 설치
            pip install fastapi uvicorn mysql-connector-python;
            
            # 2. 메인 애플리케이션 코드 생성
            cat <<EOF > main.py
            from fastapi import FastAPI
            import mysql.connector
            import os

            app = FastAPI()

            # DB 접속 정보 (서비스 이름을 호스트로 지정)
            DB_WRITE = {"host": "mysql-write", "user": "admin", "password": "12345678", "database": "employees"}
            DB_READ  = {"host": "mysql-read",  "user": "admin", "password": "12345678", "database": "employees"}

            @app.get("/")
            def read_root():
                return {"status": "Online", "service": "FastAPI Backend"}

            # [쓰기 예제] 새로운 부서 추가 (Primary 전용)
            @app.post("/dept/{name}")
            def add_department(name: str):
                conn = mysql.connector.connect(**DB_WRITE)
                cursor = conn.cursor()
                try:
                    # 데이터 입력 (쓰기 서비스 호출)
                    cursor.execute("INSERT INTO departments (dept_no, dept_name) VALUES (%s, %s)", ('d888', name))
                    conn.commit()
                    return {"result": "success", "msg": f"Dept {name} added to Primary"}
                except Exception as e:
                    return {"result": "error", "msg": str(e)}
                finally:
                    cursor.close()
                    conn.close()

            # [읽기 예제] 부서 목록 조회 (전체 로드밸런싱)
            @app.get("/depts")
            def list_departments():
                conn = mysql.connector.connect(**DB_READ)
                cursor = conn.cursor()
                # 3대의 서버 중 하나로부터 데이터 조회
                cursor.execute("SELECT * FROM departments WHERE dept_no = 'd888'")
                data = cursor.fetchall()
                cursor.close()
                conn.close()
                return {"source": "mysql-read-loadbalancer", "data": data}
            EOF
            
            # 3. FastAPI 서버 기동
            python3 -m uvicorn main:app --host 0.0.0.0 --port 8000
        ports:
        - containerPort: 8000

```

---

### 3. 설치 및 실행 방법

**단계 1: 백엔드 서버 배포**

```bash
kubectl apply -f fastapi-deployment.yaml

```

**단계 2: 서비스 포트 확인**
이미 생성된 인그레스(`/bucket`)를 통해 외부에서 접속이 가능한지 확인합니다.

```bash
kubectl get ingress -n wb_prod

```

---

### 4. 테스트 및 확인 방법

**방법 1: 데이터 쓰기(POST) 테스트**
쓰기 전용 서비스를 거쳐 Primary 서버에 데이터가 정상적으로 저장되는지 확인합니다.

```bash
curl -X POST http://192.168.0.251/bucket/dept/Cloud_Team

```

**방법 2: 데이터 읽기(GET) 및 분산 확인**
읽기 로드밸런서를 통해 데이터가 조회되는지 확인합니다. 앞서 설정한 대로 Primary를 포함한 3대의 서버가 이 요청을 나누어 처리합니다.

```bash
curl http://192.168.0.251/bucket/depts

```

---

### 5. 핵심 관리 포인트

* **서비스 추상화**: 애플리케이션 코드는 `mysql-write`가 1대인지, `mysql-read`가 3대인지 알 필요가 없습니다. 오직 서비스 이름으로 통신하며, 인프라의 변화(서버 증설 등)에 영향을 받지 않습니다.
* **고가용성**: 백엔드 서버 자체도 2대(`replicas: 2`)로 구성하여, 하나의 포드에 장애가 발생해도 서비스가 유지되도록 설계했습니다.
* **데이터 흐름의 명확성**: 쓰기는 마스터로, 읽기는 전체 클러스터로 분산시키는 전략을 통해 DB 성능을 최적화했습니다.

> [!IMPORTANT]
> **과금 및 자원 안내**:
> FastAPI 포드가 2대 추가되었으므로 워커 노드의 메모리 점유율을 확인하십시오. **내부 서비스 간 통신은 AWS 트래픽 과금이 발생하지 않습니다.**

---

Next Step: **DB 접속 정보(ID/PW)를 소스 코드에서 분리하여 Kubernetes Secret으로 보안 강화하기**

---

Next Step: **back-pvc**
