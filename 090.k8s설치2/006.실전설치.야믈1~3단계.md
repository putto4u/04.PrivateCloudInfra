# 프로젝트: Kubernetes v1.30 자동화 설치 및 인프라 최적화 가이드

이 프로젝트는 **앤서블(Ansible)**을 활용하여 여러 대의 **예비서버(pc)**에 Kubernetes v1.30 환경을 자동으로 구축합니다. 특히 가상 머신 복제로 인해 발생하는 **머신 아이디(Machine ID)** 중복 문제와 **컨테이너 런타임(Containerd)**의 CRI 비활성화 문제를 해결하여, 설치 실패 시에도 안전하게 재시행할 수 있는 멱등성(Idempotency) 확보에 초점을 맞춥니다.

---

### 1. 인프라 구성 정의

| 역할 | 명칭 | 주요 임무 |
| --- | --- | --- |
| **컨트롤 노드** | **마스터 PC** | 앤서블 플레이북 실행 및 클러스터 배포 관리 |
| **타겟 노드** | **예비서버(pc)** | Kubernetes 컴포넌트(Kubeadm, Kubelet 등) 설치 대상 |

> **AWS 과금 주의**: EC2 인스턴스를 사용할 경우, 인스턴스 유형(t3.medium 이상 권장) 및 사용 시간에 따라 비용이 발생합니다. 실습 종료 후 반드시 인스턴스를 '중지'하거나 '종료'하여 불필요한 비용 발생을 방지하세요.

---

### 2. [사전 준비] 인벤토리 파일(hosts.ini) 작성

앤서블이 작업을 수행할 **예비서버(pc)**들을 정의합니다. **마스터 PC**의 작업 디렉토리에 생성합니다.

```ini
[k8s_cluster]
# 예비서버(pc)의 식별 이름과 실제 IP 주소를 기입합니다.
master-node   ansible_host=192.168.100.10
worker-node1  ansible_host=192.168.100.11
worker-node2  ansible_host=192.168.100.12

[all:vars]
# 접속에 사용할 사용자 계정 및 권한 상승 설정
ansible_user=ubuntu
ansible_become_pass=your_sudo_password

```

---

### 3. [핵심] Ansible Playbook: k8s_setup.yml

복제된 VM의 식별자 충돌 방지와 컨테이너 런타임 최적화를 포함한 최종본입니다.

```yaml
- name: Kubernetes v1.30 환경 최적화 및 설치 (멱등성 강화 버전)
  hosts: k8s_cluster
  become: yes
  vars:
    internal_network: "192.168.100.0/24"

  tasks:
    # [1] 가상 머신 복제 시 발생하는 머신 아이디 중복 해결
    - name: Machine ID 초기화 및 재생성 (네트워크 충돌 방지)
      shell: |
        if [ -s /etc/machine-id ]; then
          truncate -s 0 /etc/machine-id
          systemd-machine-id-setup
        fi
      args:
        executable: /bin/bash

    # [2] 시스템 잠금 및 자동 업데이트 간섭 제거
    - name: APT 시스템 상태 정상화
      shell: |
        systemctl stop unattended-upgrades || true
        killall -9 apt-get apt dpkg 2>/dev/null || true
        rm -f /var/lib/dpkg/lock-frontend /var/lib/apt/lists/lock
        dpkg --configure -a
      ignore_errors: yes

    # [3] 네트워크 및 커널 최적화
    - name: Swap 메모리 비활성화
      shell: |
        swapoff -a
        sed -i '/swap/s/^/#/' /etc/fstab

    - name: 커널 모듈 로드 및 네트워크 파라미터 설정
      copy:
        dest: "{{ item.path }}"
        content: "{{ item.content }}"
      loop:
        - { path: '/etc/modules-load.d/k8s.conf', content: "overlay\nbr_netfilter" }
        - { path: '/etc/sysctl.d/k8s.conf', content: "net.bridge.bridge-nf-call-iptables = 1\nnet.bridge.bridge-nf-call-ip6tables = 1\nnet.ipv4.ip_forward = 1" }

    - name: 커널 설정 즉시 적용
      command: "{{ item }}"
      loop:
        - modprobe overlay
        - modprobe br_netfilter
        - sysctl --system

    # [4] 런타임(Containerd) 설치 및 CRI/Cgroup 최적화
    - name: Containerd 설치 (입력 대기 방지)
      apt:
        name: containerd
        state: present
        update_cache: yes
      environment:
        DEBIAN_FRONTEND: noninteractive

    - name: Containerd 기본 설정 파일 생성 (부실한 설정 교체)
      shell: |
        mkdir -p /etc/containerd
        containerd config default > /etc/containerd/config.toml
      # SystemdCgroup 설정이 없거나 CRI가 비활성화된 경우에만 실행
      when: >
        'SystemdCgroup' not in lookup('file', '/etc/containerd/config.toml', errors='ignore') or
        'disabled_plugins = ["cri"]' in lookup('file', '/etc/containerd/config.toml', errors='ignore')
      notify: restart containerd

    - name: Containerd Cgroup 드라이버 및 CRI 활성화
      replace:
        path: /etc/containerd/config.toml
        regexp: "{{ item.regexp }}"
        replace: "{{ item.replace }}"
      loop:
        - { regexp: 'SystemdCgroup = false', replace: 'SystemdCgroup = true' }
        - { regexp: 'disabled_plugins = \["cri"\]', replace: 'disabled_plugins = []' }
      notify: restart containerd

    # [5] Kubernetes v1.30 패키지 설정
    - name: K8s GPG 키 및 저장소 설정
      shell: |
        mkdir -p /etc/apt/keyrings
        curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.30/deb/Release.key | gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg
        echo "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.30/deb/ /" > /etc/apt/sources.list.d/kubernetes.list
      args:
        creates: /etc/apt/sources.list.d/kubernetes.list

    - name: K8s 도구 설치 및 버전 고정
      apt:
        name: ["kubelet=1.30.*", "kubeadm=1.30.*", "kubectl=1.30.*"]
        state: present
        update_cache: yes
      environment:
        DEBIAN_FRONTEND: noninteractive

    - name: 패키지 업데이트 고정 (Hold)
      dpkg_selections:
        name: "{{ item }}"
        selection: hold
      loop: [kubelet, kubeadm, kubectl]

    # [6] 방화벽(UFW) 설정
    - name: 필수 포트 허용 및 UFW 활성화
      ufw:
        rule: allow
        port: "{{ item.port | default(omit) }}"
        from_ip: "{{ item.from | default(omit) }}"
        proto: tcp
      loop:
        - { from: "{{ internal_network }}" }
        - { port: '22' }
        - { port: '6443' }
        - { port: '10250' }
        - { port: '30000:32767' }

    - name: UFW 활성화
      ufw:
        state: enabled
        policy: deny

  handlers:
    - name: restart containerd
      service:
        name: containerd
        state: restarted

```

---

### 4. 프로젝트 실행 및 재시행 가이드

#### 1) 초기 실행 방법

**마스터 PC**에서 아래 명령어를 실행합니다.

```bash
export ANSIBLE_HOST_KEY_CHECKING=False
ansible-playbook -i hosts.ini k8s_setup.yml -K

```

#### 2) 재실행 시나리오

설치 도중 오류가 발생하면 동일한 명령어를 다시 실행하세요.

* **Containerd**: 설정 파일 내용이 부실하면 자동으로 재생성하고, 올바르면 스킵합니다.
* **Machine ID**: 중복 여부를 체크하여 네트워크 충돌을 사전에 방지합니다.

---

### 5. 설치 결과 검증 (Verification)

앤서블 완료 후 **예비서버(pc)**에서 상태를 최종 점검합니다.

1. **CRI 활성화 확인**: `sudo crictl info` 실행 시 에러 없이 정보가 출력되어야 합니다.
2. **Cgroup 드라이버**: `grep "SystemdCgroup = true" /etc/containerd/config.toml` 결과가 존재해야 합니다.
3. **서비스 상태**: `systemctl status containerd kubelet`이 `active (running)`인지 확인합니다.

---

### 6. 강사의 실전 팁: 초기화 전 최종 체크

복제된 가상 머신을 사용할 경우 `/etc/machine-id`가 같으면 DHCP 서버가 동일한 IP를 할당하거나 K8s 노드 식별에 문제가 생깁니다. 플레이북 내의 머신 아이디 초기화 단계가 정상적으로 수행되었는지 각 노드에서 확인하세요. 또한 `unattended-upgrades`가 실행 중이면 패키지 설치가 멈출 수 있으므로 강제 종료 태스크를 반드시 포함해야 합니다.

---

Next Step: 마스터 노드에서 `kubeadm init` 수행 및 Join 토큰 생성 방법

#### 2) 설치 실패 후 재실행 시나리오

작업 도중 네트워크 끊김이나 패키지 락으로 실패했을 경우, 수동 조치 없이 **동일한 명령어를 다시 실행**하면 됩니다.

* **설정 파일**: `creates` 옵션에 의해 기존 설정이 존재하면 덮어쓰지 않고 건너뜁니다.
* **패키지**: 이미 설치된 경우 `present` 상태를 확인하고 다음 단계로 넘어갑니다.
* **방화벽**: 중복된 규칙은 무시하고 최종 상태(Enabled)만 유지합니다.

---

### 5. 트러블슈팅 및 실전 팁

* **접속 테스트**: 플레이북 실행 전 `ansible all -i hosts.ini -m ping` 명령어로 모든 **예비서버(pc)**와의 통신 상태를 먼저 확인하는 것이 좋습니다.
* **Containerd 설정 꼬임**: 만약 `config.toml` 설정이 잘못되었다면, 해당 파일을 삭제(`rm`)하고 플레이북을 재실행하면 깨끗한 기본값으로 다시 생성됩니다.
* **APT 락 지속**: `dpkg --configure -a`가 포함되어 있어 대부분의 잠금 문제는 자동 해결되지만, 지속될 경우 리부팅 후 재실행이 가장 확실합니다.

---

---

### 6. 설치 결과 검증 및 상태 확인 (Verification)

앤서블 플레이북 실행이 완료된 후, **예비서버(pc)**들에서 Kubernetes 구성 요소들이 정상적으로 설치되고 구동 준비가 되었는지 확인하는 단계입니다.

#### 1) 핵심 서비스 구동 상태 확인

Kubernetes의 엔진인 `containerd`와 노드 관리 요원인 `kubelet`이 활성화되어 있는지 확인합니다.

```bash
# 컨테이너 런타임 및 kubelet 상태 확인 (Active: active (running) 인지 확인)
systemctl status containerd kubelet --no-pager

```

#### 2) 패키지 버전 및 설치 경로 검증

플레이북에서 지정한 **v1.30** 버전이 올바르게 설치되었고, 업데이트 고정(hold) 설정이 적용되었는지 확인합니다.

```bash
# 설치된 버전 확인
kubeadm version -o short
kubectl version --client

# 패키지 홀드(hold) 상태 확인 (hi 표시가 되어 있어야 함)
dpkg --get-selections | grep -E 'kubelet|kubeadm|kubectl'

```

#### 3) 컨테이너 런타임 통신 확인

`crictl` 도구를 사용하여 런타임(Containerd)이 Kubernetes와 통신할 준비가 되었는지 점검합니다.

```bash
# 런타임 정보 출력 테스트
sudo crictl info

```

#### 4) 방화벽(UFW) 규칙 적용 확인

설정한 포트(6443, 10250 등)가 외부와 내부 대역에 대해 정상적으로 개방되었는지 확인합니다.

```bash
# 적용된 방화벽 규칙 리스트 출력
sudo ufw status numbered

```

---

### 7. 강사의 실전 팁: 초기화 전 최종 체크

모든 노드에서 위 검증이 완료되었다면 이제 클러스터를 구성할 준비가 끝난 것입니다. 만약 특정 노드에서 서비스가 `inactive` 상태라면, 플레이북을 다시 실행하거나 `journalctl -u kubelet` 명령어를 통해 로그를 분석하여 네트워크 및 스왑(Swap) 비활성화 여부를 다시 한번 점검하세요.

---

Next Step: 마스터 노드에서 `kubeadm init` 수행 및 Join 토큰 생성 방법

---

설치 검증 단계를 추가하여 교재의 완결성을 높였습니다. 이제 수강생들은 설치 직후 자신의 환경이 정상인지 스스로 판단할 수 있습니다.

Next Step: 노드 간 인증을 위한 SSH 키 배포 및 자동화 구성 방법
