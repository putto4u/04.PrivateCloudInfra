

# 프로젝트: Kubernetes v1.30 자동화 설치 및 재설치 가이드

이 프로젝트는 **앤서블(Ansible)**을 활용하여 여러 대의 **예비서버(pc)**에 Kubernetes v1.30 환경을 자동으로 구축하고, 설치 실패 시에도 안전하게 재시행할 수 있는 멱등성(Idempotency) 확보에 초점을 맞춥니다.


hosts.ini
---

### 1. 인프라 구성 정의

| 역할 | 명칭 | 주요 임무 |
| --- | --- | --- |
| **컨트롤 노드** | **마스터 PC** | 앤서블 플레이북 실행 및 클러스터 배포 관리 |
| **타겟 노드** | **예비서버(pc)** | Kubernetes 컴포넌트(Kubeadm, Kubelet 등) 설치 대상 |

> **AWS 과금 주의**: EC2 인스턴스를 사용하여 실습할 경우, 인스턴스 유형(t3.medium 이상 권장) 및 사용 시간에 따라 비용이 발생합니다. 실습 종료 후 반드시 인스턴스를 '중지'하거나 '종료'하세요.

---

### 2. [사전 준비] 인벤토리 파일(hosts.ini) 작성

앤서블이 어느 **예비서버(pc)**에 접속하여 작업을 수행할지 정의하는 설정 파일입니다. **마스터 PC**의 작업 디렉토리에 생성합니다.

```ini
# k8s_setup.yml이 적용될 대상 그룹 정의
[k8s_cluster]
# 예비서버(pc)의 식별 이름과 실제 IP 주소를 기입합니다.
master-node   ansible_host=192.168.100.10
worker-node1  ansible_host=192.168.100.11
worker-node2  ansible_host=192.168.100.12

[all:vars]
# 접속에 사용할 사용자 계정 (Ubuntu 기본값: ubuntu)
ansible_user=ubuntu

# SSH 키 경로 (비밀번호 없이 접속할 경우)
# ansible_ssh_private_key_file=~/.ssh/id_rsa

# 만약 비밀번호를 사용한다면 아래 옵션을 고려합니다.
# ansible_ssh_pass=your_password
# ansible_become_pass=your_sudo_password

```

---

### 3. [핵심] Ansible Playbook: k8s_setup.yml

기존 코드에서 실패 시 재실행 안정성을 강화한 최종본입니다.

```yaml
- name: Kubernetes v1.30 환경 최적화 및 설치 (멱등성 강화 버전)
  hosts: k8s_cluster
  become: yes
  vars:
    internal_network: "192.168.100.0/24"

  tasks:
    # [1] 시스템 잠금 및 꼬인 패키지 복구 (재설치 시 핵심)
    - name: APT 시스템 상태 정상화
      shell: |
        systemctl stop unattended-upgrades || true
        killall -9 apt-get apt dpkg 2>/dev/null || true
        dpkg --configure -a
        apt-get clean
      ignore_errors: yes

    # [2] 네트워크 및 커널 최적화
    - name: Swap 메모리 비활성화
      shell: |
        swapoff -a
        sed -i '/swap/s/^/#/' /etc/fstab

    - name: 커널 모듈 로드 설정
      copy:
        dest: /etc/modules-load.d/k8s.conf
        content: |
          overlay
          br_netfilter

    - name: 커널 모듈 즉시 로드
      command: modprobe {{ item }}
      loop: [overlay, br_netfilter]

    - name: sysctl 네트워크 파라미터 설정
      copy:
        dest: /etc/sysctl.d/k8s.conf
        content: |
          net.bridge.bridge-nf-call-iptables  = 1
          net.bridge.bridge-nf-call-ip6tables = 1
          net.ipv4.ip_forward                 = 1

    - name: sysctl 설정 즉시 적용
      command: sysctl --system

    # [3] 런타임(Containerd) 설치 및 멱등성 기반 설정
    - name: Containerd 설치
      apt:
        name: containerd
        state: present
        update_cache: yes

    - name: Containerd 기본 설정 파일 생성 (존재하지 않을 때만)
      shell: |
        mkdir -p /etc/containerd
        containerd config default > /etc/containerd/config.toml
      args:
        creates: /etc/containerd/config.toml

    - name: Containerd Cgroup 드라이버를 systemd로 설정
      replace:
        path: /etc/containerd/config.toml
        regexp: 'SystemdCgroup = false'
        replace: 'SystemdCgroup = true'
      notify: restart containerd

    # [4] Kubernetes v1.30 패키지 설정
    - name: GPG 키 및 저장소 설정 (중복 방지)
      shell: |
        mkdir -p /etc/apt/keyrings
        curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.30/deb/Release.key | gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg
      args:
        creates: /etc/apt/keyrings/kubernetes-apt-keyring.gpg

    - name: K8s 소스 리스트 추가
      apt_repository:
        repo: "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.30/deb/ /"
        filename: kubernetes
        update_cache: yes

    - name: K8s 도구(1.30.x) 설치 및 버전 고정
      apt:
        name: ["kubelet=1.30.*", "kubeadm=1.30.*", "kubectl=1.30.*"]
        state: present
        force: yes

    - name: 패키지 업데이트 고정 (Hold)
      dpkg_selections:
        name: "{{ item }}"
        selection: hold
      loop: [kubelet, kubeadm, kubectl]

    # [5] 방화벽 설정
    - name: UFW 규칙 적용 (내부 네트워크 및 필수 포트)
      ufw:
        rule: allow
        port: "{{ item.port | default(omit) }}"
        from_ip: "{{ item.from | default(omit) }}"
        proto: tcp
      loop:
        - { from: "{{ internal_network }}" }
        - { port: '22' }
        - { port: '6443' }
        - { port: '10250' }
        - { port: '30000:32767' }

    - name: UFW 활성화 및 기본 차단 설정
      ufw:
        state: enabled
        policy: deny

  handlers:
    - name: restart containerd
      service:
        name: containerd
        state: restarted

```

---

### 4. 프로젝트 실행 및 재시행 가이드

#### 1) 초기 실행 방법

**마스터 PC**에서 작성한 인벤토리 파일을 사용하여 플레이북을 실행합니다.

```bash
# SSH 지문 확인 스킵 설정 (선택사항)
export ANSIBLE_HOST_KEY_CHECKING=False

# 플레이북 실행
ansible-playbook -i hosts.ini k8s_setup.yml -K

# -i 옵션으로 hosts.ini 지정, -K 옵션으로 sudo 비밀번호 입력 프롬프트 활성화
ansible-playbook -i hosts.ini k8s_setup.yml -K

```

#### 2) 설치 실패 후 재실행 시나리오

작업 도중 네트워크 끊김이나 패키지 락으로 실패했을 경우, 수동 조치 없이 **동일한 명령어를 다시 실행**하면 됩니다.

* **설정 파일**: `creates` 옵션에 의해 기존 설정이 존재하면 덮어쓰지 않고 건너뜁니다.
* **패키지**: 이미 설치된 경우 `present` 상태를 확인하고 다음 단계로 넘어갑니다.
* **방화벽**: 중복된 규칙은 무시하고 최종 상태(Enabled)만 유지합니다.

---

### 5. 트러블슈팅 및 실전 팁

* **접속 테스트**: 플레이북 실행 전 `ansible all -i hosts.ini -m ping` 명령어로 모든 **예비서버(pc)**와의 통신 상태를 먼저 확인하는 것이 좋습니다.
* **Containerd 설정 꼬임**: 만약 `config.toml` 설정이 잘못되었다면, 해당 파일을 삭제(`rm`)하고 플레이북을 재실행하면 깨끗한 기본값으로 다시 생성됩니다.
* **APT 락 지속**: `dpkg --configure -a`가 포함되어 있어 대부분의 잠금 문제는 자동 해결되지만, 지속될 경우 리부팅 후 재실행이 가장 확실합니다.

---

---

### 6. 설치 결과 검증 및 상태 확인 (Verification)

앤서블 플레이북 실행이 완료된 후, **예비서버(pc)**들에서 Kubernetes 구성 요소들이 정상적으로 설치되고 구동 준비가 되었는지 확인하는 단계입니다.

#### 1) 핵심 서비스 구동 상태 확인

Kubernetes의 엔진인 `containerd`와 노드 관리 요원인 `kubelet`이 활성화되어 있는지 확인합니다.

```bash
# 컨테이너 런타임 및 kubelet 상태 확인 (Active: active (running) 인지 확인)
systemctl status containerd kubelet --no-pager

```

#### 2) 패키지 버전 및 설치 경로 검증

플레이북에서 지정한 **v1.30** 버전이 올바르게 설치되었고, 업데이트 고정(hold) 설정이 적용되었는지 확인합니다.

```bash
# 설치된 버전 확인
kubeadm version -o short
kubectl version --client

# 패키지 홀드(hold) 상태 확인 (hi 표시가 되어 있어야 함)
dpkg --get-selections | grep -E 'kubelet|kubeadm|kubectl'

```

#### 3) 컨테이너 런타임 통신 확인

`crictl` 도구를 사용하여 런타임(Containerd)이 Kubernetes와 통신할 준비가 되었는지 점검합니다.

```bash
# 런타임 정보 출력 테스트
sudo crictl info

```

#### 4) 방화벽(UFW) 규칙 적용 확인

설정한 포트(6443, 10250 등)가 외부와 내부 대역에 대해 정상적으로 개방되었는지 확인합니다.

```bash
# 적용된 방화벽 규칙 리스트 출력
sudo ufw status numbered

```

---

### 7. 강사의 실전 팁: 초기화 전 최종 체크

모든 노드에서 위 검증이 완료되었다면 이제 클러스터를 구성할 준비가 끝난 것입니다. 만약 특정 노드에서 서비스가 `inactive` 상태라면, 플레이북을 다시 실행하거나 `journalctl -u kubelet` 명령어를 통해 로그를 분석하여 네트워크 및 스왑(Swap) 비활성화 여부를 다시 한번 점검하세요.

---

Next Step: 마스터 노드에서 `kubeadm init` 수행 및 Join 토큰 생성 방법

---

설치 검증 단계를 추가하여 교재의 완결성을 높였습니다. 이제 수강생들은 설치 직후 자신의 환경이 정상인지 스스로 판단할 수 있습니다.

Next Step: 노드 간 인증을 위한 SSH 키 배포 및 자동화 구성 방법
