
---

## 쿠버네티스 v1.30.14 클러스터 구축 최종 실무 프로세스

실무에서는 **'인프라의 상태를 코드로 관리(IaC)'**하기 위해 모든 설정값을 YAML 파일에 명시하고, 이를 통해 클러스터의 일관성을 유지합니다.

### 1. 구축 공정 목차

1. **[사전 설정]** 커널 모듈 및 네트워크 파라미터 최적화 (모든 노드)
2. **[런타임 준비]** Containerd 설치 및 Cgroup Driver 설정 (모든 노드)
3. **[도구 설치]** K8s v1.30.14 패키지 설치 및 고정 (모든 노드)
4. **[설계]** `v1beta4` 기반 마스터 노드 설정 파일(YAML) 생성 및 수정
5. **[구축]** YAML 기반 마스터 노드 초기화 및 관리자 환경 설정
6. **[네트워크]** 파드 간 통신을 위한 CNI(Calico) 배포
7. **[확장]** Join Token을 이용한 워커 노드 연결 및 최종 검증

---

### 2. 단계별 실행 가이드

#### 1단계: OS 환경 최적화 (모든 노드)

쿠버네티스가 노드 간 네트워크 패킷을 정상적으로 라우팅할 수 있도록 설정합니다.

```bash
# 스왑 비활성화 및 영구 적용
sudo swapoff -a && sudo sed -i '/swap/s/^/#/' /etc/fstab

# 커널 모듈 로드 (네트워크 브릿지 및 오버레이)
cat <<EOF | sudo tee /etc/modules-load.d/k8s.conf
overlay
br_netfilter
EOF
sudo modprobe overlay && sudo modprobe br_netfilter

# 네트워크 파라미터 설정 (L3 포워딩 활성화)
cat <<EOF | sudo tee /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-iptables  = 1
net.bridge.bridge-nf-call-ip6tables = 1
net.ipv4.ip_forward                 = 1
EOF
sudo sysctl --system

```

#### 2단계: 컨테이너 런타임(Containerd) 최적화 (모든 노드)

런타임 설치 후, 쿠버네티스와의 OS 관리 방식(systemd)을 일치시키는 작업이 필수입니다.

```bash
sudo apt-get update && sudo apt-get install -y containerd

# 기본 설정 생성 및 SystemdCgroup 활성화 수정
sudo mkdir -p /etc/containerd
containerd config default | sudo tee /etc/containerd/config.toml
sudo sed -i 's/SystemdCgroup = false/SystemdCgroup = true/g' /etc/containerd/config.toml
sudo systemctl restart containerd

```

#### 3단계: K8s 도구 설치 (모든 노드)

질문하신 **v1.30.14** 버전을 명시하여 설치합니다.

```bash
# 레포지토리 설정 후 버전 명시하여 설치
sudo apt-get install -y kubelet=1.30.14-1.1 kubeadm=1.30.14-1.1 kubectl=1.30.14-1.1
sudo apt-mark hold kubelet kubeadm kubectl

```

#### 4단계: `v1beta4` 기반 설계도 작성 (마스터 노드)

설치 전, 현재 버전에 맞는 최신 템플릿을 추출하고 수정합니다.

```bash
kubeadm config print init-defaults --component-configs KubeletConfiguration > kubeadm-init.yaml
# vi kubeadm-init.yaml 실행하여 아래 핵심 내용 수정
# 1. advertiseAddress: 마스터IP
#    nodeRegistration.name이 node  에서 node를 k8smaster 등 호스트네임으로 변경. 나중에 변경 불가
# 2. kubernetesVersion: 1.30.14
# 3. podSubnet: 10.244.0.0/16
# 4. cgroupDriver: systemd (KubeletConfiguration 섹션)

```

#### 5단계: 마스터 노드 가동 및 관리 권한 부여 (마스터 노드)

```bash
# 선언형 구축 실행
sudo kubeadm init --config kubeadm-init.yaml

# 관리자(kubectl) 권한 설정 (이 작업이 빠지면 kubectl 명령이 작동하지 않음)
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config

```

#### 6단계: 파드 네트워크(CNI) 배포 (마스터 노드)

노드 상태를 `Ready`로 만들고 파드 간 통신을 활성화합니다.

```bash
# Calico CNI 설치 (실무 표준 중 하나)
kubectl apply -f https://raw.githubusercontent.com/projectcalico/calico/v3.28.0/manifests/calico.yaml

# 최신 버전의 Flannel manifest 적용
kubectl apply -f https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml
```

#### 7단계: 워커 노드 조인 및 상태 확인

```bash
# 워커 노드에서 마스터가 발행한 조인 토큰 실행
master@vm1:~$ sudo kubeadm join 192.168.100.251:6443 --token oe5dkx.dlwmgdd0q3135iry --discovery-token-ca-cert-hash sha256:65fd5196d5da8d15de93cdd30fdfbca1bd4787e226ead36c5860bcf2124c7df3 --cri-socket /run/containerd/containerd.sock



# 마스터에서 노드 상태 최종 확인
kubectl get nodes

```

## 설정 파일 전송

`/etc/kubernetes/admin.conf` 파일은 **root** 사용자만 읽을 수 있는 권한(`600`)으로 설정되어 있습니다. 따라서 일반 사용자 계정으로 `scp`를 실행하면 파일에 접근하지 못해 **Permission denied** 에러가 발생합니다.

이 문제를 해결하려면 파일을 임시로 복사하여 소유권을 변경한 뒤 전송해야 합니다.

---

### 1. Master Node에서 파일 복사 준비

먼저 마스터 노드에서 일반 사용자(`master`)가 읽을 수 있는 위치로 파일을 복사하고 소유권을 변경합니다.

```bash
# 1. 관리자 권한으로 파일을 홈 디렉토리로 복사
sudo cp /etc/kubernetes/admin.conf $HOME/admin.conf

# 2. 복사된 파일의 소유권을 현재 사용자(master)로 변경
sudo chown $(id -u):$(id -g) $HOME/admin.conf

```

---

### 2. SCP 전송 실행

이제 권한이 부여된 파일을 워커 노드로 전송합니다.

```bash
# 3. 워커 노드(192.168.0.201)로 파일 전송
scp $HOME/admin.conf master@192.168.0.201:~

```

---

### 3. Worker Node에서 설정 마무리

워커 노드에 접속하여 전송받은 파일을 `kubectl`이 인식하는 경로로 이동시킵니다.

```bash
# 4. 워커 노드에서 실행
mkdir -p $HOME/.kube
mv $HOME/admin.conf $HOME/.kube/config
chmod 600 $HOME/.kube/config

```

**검증:**

```bash
kubectl get nodes

```

---

## kubectl 명령어 자동 완성(Autocompletion) 설정

쿠버네티스의 명령어인 `kubectl`은 매우 방대하고 복잡합니다. 매번 전체 명령어를 입력하는 대신, 탭(Tab) 키를 활용한 자동 완성 기능을 설정하면 오타를 줄이고 작업 속도를 획기적으로 높일 수 있습니다.

---

### 1. bash-completion 패키지 설치

자동 완성 기능을 사용하려면 먼저 리눅스 시스템에 `bash-completion` 패키지가 설치되어 있어야 합니다.

```bash
# 패키지 업데이트 및 설치
sudo apt-get update
sudo apt-get install -y bash-completion

```

---

### 2. kubectl 자동 완성 활성화

`kubectl` 자체적으로 제공하는 completion 스크립트를 쉘에 등록해야 합니다.

* **현재 세션에 즉시 적용:**
```bash
source <(kubectl completion bash)

```


* **영구 적용 (추천):**
사용자의 `.bashrc` 파일에 추가하여 로그아웃 후에도 유지되도록 설정합니다.
```bash
echo 'source <(kubectl completion bash)' >> ~/.bashrc
source ~/.bashrc

```



---

### 3. Alias(별칭)와 자동 완성 함께 사용하기

실무에서는 `kubectl` 대신 `k`라는 짧은 별칭을 주로 사용합니다. 단순히 별칭만 지정하면 자동 완성 기능이 작동하지 않으므로, 별칭 전용 완성 규칙을 추가해야 합니다.

```bash
# 1. k 별칭 설정
echo 'alias k=kubectl' >> ~/.bashrc

# 2. k 별칭에도 자동 완성 적용
echo 'complete -o default -F __start_kubectl k' >> ~/.bashrc

# 3. 변경 사항 반영
source ~/.bashrc

```

이제 `k get no [TAB]`과 같이 입력하면 `k get nodes`로 자동 완성되는 것을 확인할 수 있습니다.

---

### 4. 실전 활용 팁 및 트러블슈팅

* **명령어 추천:** `kubectl` 다음에 한 칸 띄우고 `[TAB]`을 두 번 누르면 사용 가능한 모든 리소스(pod, service, deployment 등)를 보여줍니다.
* **리소스 이름 완성:** `kubectl get pods [TAB]`을 누르면 현재 네임스페이스에 존재하는 Pod들의 이름까지 자동으로 추천해 줍니다.
* **동작하지 않을 경우:**
* `type _init_completion` 명령어를 실행했을 때 아무것도 나오지 않는다면 `bash-completion`이 제대로 로드되지 않은 것입니다. 이 경우 `/etc/profile.d/bash_completion.sh`를 소싱해야 합니다.



## Kubernetes 노드 이름 변경 (Hostname 수정)

쿠버네티스에서 노드의 이름은 API 서버에 등록되는 **불변(Immutable)의 식별자**입니다. 즉, 단순히 명령어로 `node`라는 이름을 `k8master01`로 바꿀 수는 없으며, 기존 노드 객체를 삭제하고 변경된 호스트네임으로 다시 등록하는 과정을 거쳐야 합니다.

---

### 1. 주의사항 및 사전 확인

특히 **Control-plane(Master Node)**의 이름을 변경할 때는 다음 사항을 반드시 숙지해야 합니다.

* **인증서 재발급:** 쿠버네티스 인증서(`apiserver.crt` 등)는 호스트네임을 기반으로 생성되는 경우가 많아 이름 변경 시 인증서 문제가 발생할 수 있습니다.
* **etcd 데이터:** etcd 클러스터 멤버 이름이 기존 호스트네임과 묶여 있어 관리에 주의가 필요합니다.
* **가장 깔끔한 방법:** `kubeadm reset` 후 호스트네임을 변경하고 `kubeadm init`을 다시 수행하는 것이 교재 구성 및 실습 환경 구축 측면에서 가장 안정적입니다.

---

### 2. 마스터 노드 이름 변경 단계 (Re-init 방식)

### 실전 Tip: 이름 변경 없이 라벨(Label) 활용하기

만약 관리 목적으로 이름을 바꾸려는 것이라면, 실제 이름을 바꾸는 위험을 감수하는 대신 **Label**을 추가하여 분류하는 것을 권장합니다.

```bash
# 노드에 논리적인 관리 명칭 부여
kubectl label node node custom-name=k8master01

```

이 방식은 기존 클러스터 설정을 초기화하고 새로운 이름으로 다시 구성하는 표준 절차입니다.

#### 1단계: 노드 삭제 및 초기화 (Master)

```bash
# 마스터 노드에서 실행
sudo kubeadm reset -f
rm -rf $HOME/.kube
sudo rm -rf /etc/cni/net.d

```

#### 2단계: 운영체제 호스트네임 변경

리눅스 시스템 레벨에서 호스트네임을 영구적으로 변경합니다.

```bash
# 호스트네임을 k8master01로 변경
sudo hostnamectl set-hostname k8master01

# /etc/hosts 파일 수정 (자신의 IP와 새 호스트네임 매핑)
# 예: 192.168.0.200 k8master01
sudo vi /etc/hosts

```

#### 3단계: 클러스터 재초기화

새로운 호스트네임이 적용된 상태에서 `kubeadm init`을 실행합니다.

```bash
sudo kubeadm init --pod-network-cidr=172.16.0.0/16 --apiserver-advertise-address=192.168.0.200

```

---

### 3. 워커 노드 재연결 (Worker)

마스터 노드를 재설치하면 **Join 토큰**이 새로 생성됩니다. 기존 워커 노드들도 초기화 후 다시 조인해야 합니다.

```bash
# 워커 노드에서 실행
sudo kubeadm reset -f
sudo kubeadm join 192.168.0.200:6443 --token <NEW_TOKEN> --discovery-token-ca-cert-hash sha256:<NEW_HASH>

```

---



---

### AWS 환경 및 비용 참고

* **인스턴스 이름 vs 호스트네임:** AWS 콘솔에서 보이는 'Name' 태그와 OS 내부의 'Hostname'은 별개입니다. 쿠버네티스는 OS 내부의 호스트네임을 따릅니다.
* **비용:** 이 작업 자체에 발생하는 추가 비용은 없습니다. 다만, 클러스터 초기화 과정에서 컨테이너 이미지를 다시 Pulling 해야 하므로, 만약 NAT Gateway를 사용 중이거나 리전 간 통신이 발생한다면 미미한 수준의 **Data Transfer 비용**이 발생할 수 있습니다.

---

Next Step: 쿠버네티스 인증서 갱신 및 관리

---

현재 클러스터가 구축된 직후이므로, 이름이 마음에 들지 않는다면 위와 같이 `reset` 후 이름을 바꿔 다시 `init`하는 것이 가장 확실한 방법입니다. 교재에는 '설치 전 호스트네임 설정의 중요성' 파트로 넣으시면 수강생들에게 좋은 팁이 될 것입니다.
