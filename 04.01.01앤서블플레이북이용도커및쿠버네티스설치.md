자동화 전문가의 관점에서, **Ansible Playbook**을 이용한 Docker와 Kubernetes(K8s) 설치는 인프라를 일관되고 반복 가능하며 확장성 있게 구축하는 **가장 표준적인 방법**입니다.

Docker 설치는 비교적 간단하지만, K8s 클러스터 구축은 \*\*`kubeadm`\*\*을 기반으로 복잡한 선행 조건과 마스터/워커 노드별 작업을 요구합니다. 이 모든 과정을 하나의 Playbook 세트로 자동화하는 것이 핵심입니다.

### 1\. Ansible 환경 및 사전 준비 사항

Docker와 K8s 설치를 자동화하기 전에 다음 사항이 전제되어야 합니다.

  * **Ansible 컨트롤 노드:** Playbook을 실행할 중앙 서버(SSH 접속 및 Ansible 설치 필수).
  * **관리 대상 노드(Target Nodes):** Docker와 K8s가 설치될 VM 또는 서버. (OS: Ubuntu 또는 CentOS 권장)
  * **SSH 키 기반 인증:** 컨트롤 노드에서 모든 대상 노드로 비밀번호 없이 \*\*`ssh-copy-id`\*\*를 통해 접속 가능해야 합니다. (`ansible_become: yes` 사용 시 sudo 비밀번호 없이 권한 상승 가능)
  * **Inventory 파일 구성:** 마스터 노드와 워커 노드를 명확히 구분하는 그룹 설정이 필요합니다.

<!-- end list -->

```ini
[master]
k8s-master ansible_host=192.168.1.10

[worker]
k8s-worker1 ansible_host=192.168.1.11
k8s-worker2 ansible_host=192.168.1.12

[all:vars]
ansible_user=ubuntu 
ansible_become=yes # sudo 권한 사용
```

-----

### 2\. Playbook을 이용한 Docker 설치 (Container Runtime)

K8s는 \*\*컨테이너 런타임 인터페이스(CRI)\*\*를 필요로 합니다. **Containerd**가 쿠버네티스의 기본 런타임이지만, Docker를 포함하여 설치하는 것이 관리 편의성에서 유리할 수 있습니다.

**`docker-install.yml`** (모든 노드에서 실행)

```yaml
---
- name: 🚀 Install Docker (Container Runtime for K8s)
  hosts: all
  become: yes
  tasks:
    # 1. 시스템 업데이트 및 필수 패키지 설치
    - name: Update apt cache and install prerequisites
      ansible.builtin.apt:
        name: 
          - apt-transport-https
          - ca-certificates
          - curl
          - software-properties-common
        state: present
        update_cache: yes

    # 2. Docker GPG 키 및 Repository 추가
    - name: Add Docker GPG apt Key
      ansible.builtin.apt_key:
        url: https://download.docker.com/linux/ubuntu/gpg
        state: present
        
    - name: Add Docker Repository
      ansible.builtin.apt_repository:
        repo: deb [arch=amd64] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable
        state: present
        
    # 3. Docker Engine 및 관련 패키지 설치 (containd.io 포함)
    - name: Install Docker Packages
      ansible.builtin.apt:
        name: 
          - docker-ce
          - docker-ce-cli
          - containerd.io
        state: present

    # 4. 일반 사용자에게 Docker 권한 부여
    - name: Add user to docker group
      ansible.builtin.user:
        name: "{{ ansible_user }}"
        groups: docker
        append: yes
```

-----

### 3\. Playbook을 이용한 Kubernetes 설치 (kubeadm 기반)

쿠버네티스 설치는 **스왑 비활성화, 네트워크 설정, Kube-tools 설치, 클러스터 초기화**의 4단계로 나뉩니다.

#### A. Pre-requisite Playbook (`k8s-prep.yml`)

K8s 설치를 위한 선행 조건(모든 노드에서 필수)을 설정합니다.

```yaml
---
- name: ⚙️ Kubernetes Pre-requisites Setup
  hosts: all
  become: yes
  tasks:
    # 1. Swap 메모리 비활성화 (Kubelet 요구 사항)
    - name: Disable swap permanently (comment out fstab entry)
      ansible.builtin.replace:
        path: /etc/fstab
        regexp: '^(\s*)([^#]+\s+swap\s+sw\s+.*)$'
        replace: '#\2'
        
    - name: Turn off swap immediately
      ansible.builtin.command: swapoff -a
      when: ansible_swaptotal_mb > 0

    # 2. 브릿지 네트워크 트래픽에 대한 iptables 확인 설정 (K8s 네트워킹 필수)
    - name: Configure sysctl for Kubernetes networking
      ansible.builtin.sysctl:
        name: "{{ item }}"
        value: '1'
        state: present
        reload: yes
      loop:
        - net.bridge.bridge-nf-call-iptables
        - net.bridge.bridge-nf-call-ip6tables
        - net.ipv4.ip_forward
        
    # 3. Kubernetes Tools 설치 (kubeadm, kubelet, kubectl)
    - name: Add Kubernetes GPG Key
      ansible.builtin.apt_key:
        url: https://packages.cloud.google.com/apt/doc/apt-key.gpg
        state: present

    - name: Add Kubernetes Repository
      ansible.builtin.apt_repository:
        repo: deb https://apt.kubernetes.io/ kubernetes-xenial main
        state: present
        filename: kubernetes
        
    - name: Install kubelet, kubeadm, kubectl and hold their versions
      ansible.builtin.apt:
        name: 
          - kubelet={{ kube_version }}
          - kubeadm={{ kube_version }}
          - kubectl={{ kube_version }}
        state: present
        update_cache: yes

    - name: Mark K8s packages to hold (prevent accidental upgrade)
      ansible.builtin.dpkg_selections:
        name: "{{ item }}"
        selection: hold
      loop:
        - kubelet
        - kubeadm
        - kubectl
```

#### B. Master Node 초기화 (`k8s-master-init.yml`)

마스터 노드에서 클러스터를 초기화하고 워커 노드가 조인할 토큰을 생성합니다.

```yaml
---
- name: 👑 Initialize Kubernetes Master Node
  hosts: master
  become: yes
  vars:
    # 예: 원하는 K8s 버전 (Playbook 실행 시 --extra-vars "kube_version=1.29.0-00" 로 변경 가능)
    kube_version: "1.29.0-00" 
    pod_network_cidr: "10.244.0.0/16" # Calico CNI 표준 CIDR
  tasks:
    - name: Initialize the Kubernetes Cluster (kubeadm init)
      ansible.builtin.command: >
        kubeadm init 
        --pod-network-cidr={{ pod_network_cidr }} 
        --ignore-preflight-errors=NumCPU
      register: kubeadm_init_result # 결과 저장

    - name: Create .kube directory for cluster config
      ansible.builtin.file:
        path: /home/{{ ansible_user }}/.kube
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'
        
    - name: Copy admin.conf to user's .kube directory
      ansible.builtin.copy:
        src: /etc/kubernetes/admin.conf
        dest: /home/{{ ansible_user }}/.kube/config
        remote_src: yes
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0600'

    # Calico CNI 설치 (네트워크 플러그인)
    - name: Install Calico CNI Network Plugin
      ansible.builtin.command: >
        kubectl apply -f https://docs.projectcalico.org/manifests/calico.yaml

    # 워커 노드 조인 명령 생성 (토큰 추출)
    - name: Generate join command for worker nodes
      ansible.builtin.command: >
        kubeadm token create --print-join-command
      register: join_command_result
    
    - name: Display join command
      ansible.builtin.debug:
        msg: "Worker Join Command: {{ join_command_result.stdout }}"
      delegate_to: localhost # 결과를 컨트롤 노드 터미널에 출력
```

#### C. Worker Node 조인 (`k8s-worker-join.yml`)

워커 노드를 클러스터에 합류시킵니다. (마스터 노드에서 얻은 토큰 사용)

```yaml
---
- name: 🤝 Join Worker Nodes to Cluster
  hosts: worker
  become: yes
  tasks:
    # Master Playbook에서 생성된 토큰을 복사하여 실행
    - name: Execute join command on worker nodes
      ansible.builtin.shell: 
        cmd: "{{ hostvars['k8s-master']['join_command_result']['stdout'] }}"
      register: join_output
      changed_when: join_output.rc == 0
```

-----

### 4\. 실행 순서 및 마무리

Playbook은 순서대로 실행해야 합니다.

1.  **Docker 설치:**
    ```bash
    ansible-playbook docker-install.yml -i inventory
    ```
2.  **K8s 사전 준비:**
    ```bash
    ansible-playbook k8s-prep.yml -i inventory
    ```
3.  **마스터 노드 초기화:**
    ```bash
    ansible-playbook k8s-master-init.yml -i inventory
    ```
4.  **워커 노드 조인:**
    ```bash
    ansible-playbook k8s-worker-join.yml -i inventory
    ```

**최종 확인:** 마스터 노드에서 다음 명령을 실행하여 모든 노드가 **`Ready`** 상태인지 확인합니다.

```bash
kubectl get nodes
```

이 자동화된 접근 방식은 DevOps 환경에서 가장 효율적인 클러스터 구축 방법이며, 필요 시 **Kubespray**와 같은 전문적인 Ansible 기반 K8s 설치 도구를 사용하는 것을 고려해 볼 수 있습니다.
