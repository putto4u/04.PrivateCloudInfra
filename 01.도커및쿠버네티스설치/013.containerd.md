쿠버네티스(k8s) 아키텍처를 공부하다 보면 컴포넌트 목록(API 서버, 스케줄러 등)에는 없는데, 설치 과정에서 가장 먼저 다루는 **containerd**의 정체에 대해 의문이 생길 수 있습니다. 이를 명확히 이해하기 위해서는 쿠버네티스의 '실행 구조'를 파악해야 합니다.

---

### 1. containerd의 정체: "실제 일꾼"

쿠버네티스는 컨테이너를 관리하는 **'지휘관'**이지, 컨테이너를 직접 생성하고 실행하는 **'엔진'**은 아닙니다.

* **쿠버네티스**: "어떤 노드에 어떤 컨테이너를 몇 개 띄워라"라고 명령을 내리는 두뇌.
* **containerd**: 쿠버네티스의 명령을 받아 실제로 이미지를 다운로드하고, 컨테이너를 실행/중지시키는 **컨테이너 런타임(Container Runtime)** 엔진입니다.

---

### 2. 쿠버네티스 구조와 containerd의 관계

쿠버네티스 표준 컴포넌트 목록에 containerd가 명시되지 않는 이유는 쿠버네티스가 **CRI(Container Runtime Interface)**라는 표준 규격만 지킨다면 어떤 엔진이든 교체해서 쓸 수 있도록 설계되었기 때문입니다.

* **Kubelet과 containerd의 대화**:
워커 노드에 있는 **kubelet**이 "컨테이너 하나 띄워줘"라고 요청하면, 이 요청은 **CRI**라는 통로를 통해 **containerd**에 전달됩니다. 즉, containerd는 쿠버네티스 '내부' 컴포넌트는 아니지만, 쿠버네티스가 일을 하기 위해 반드시 필요한 **외부 핵심 파트너**입니다.

---

### 3. 왜 Docker가 아니고 containerd인가?

과거에는 Docker를 주로 사용했지만, 현재는 containerd가 표준이 되었습니다.

1. **Docker의 구조**: Docker는 일반 사용자가 쓰기 편한 기능(GUI, 빌드 도구 등)이 많아 쿠버네티스가 쓰기에는 너무 무거웠습니다.
2. **분리**: Docker 안에서 컨테이너 실행 기능만 핵심적으로 뽑아낸 것이 바로 **containerd**입니다.
3. **효율성**: 쿠버네티스는 불필요한 기능이 빠진 가볍고 빠른 containerd와 직접 통신하는 방식을 선택했습니다. (이를 통해 리소스 소모를 줄이고 안정성을 높였습니다.)

---

### 4. containerd의 핵심 역할 4가지

* **이미지 관리**: 도커 허브 등에서 이미지를 Pull 하고 저장합니다.
* **컨테이너 생명주기 관리**: 컨테이너를 생성(Start), 중지(Stop), 삭제(Delete)합니다.
* **스토리지 관리**: 컨테이너의 스냅샷과 레이어 파일을 관리합니다.
* **네트워크 연결**: 컨테이너에 가상 네트워크 인터페이스를 연결할 준비를 합니다.

---

### AWS 비용 및 유료 전환 주의사항

* **EKS 관리형 노드**: AWS EKS의 최신 버전 노드 그룹은 기본적으로 `containerd`를 런타임으로 사용하도록 세팅되어 있습니다. 사용자가 직접 설치할 필요는 없지만, 워커 노드(EC2)가 가동되는 동안 **인스턴스 비용**은 계속 발생합니다.
* **Bottlerocket OS**: AWS에서 제공하는 컨테이너 전용 OS인 Bottlerocket을 사용하면 불필요한 서비스 없이 `containerd`만 최적화되어 실행되므로 리소스 효율이 좋아지며, 이는 결국 더 작은 인스턴스를 사용할 수 있게 하여 **비용 절감**으로 이어질 수 있습니다.

Next Step: 컨테이너 런타임 인터페이스(CRI)의 동작 원리 상세 분석

쿠버네티스가 왜 직접 컨테이너를 실행하지 않고 외부 엔진을 사용하는지, 그 철학을 이해하면 전체 아키텍처가 더 명확해집니다.

Next Step: CRI 동작 원리 이해하기
