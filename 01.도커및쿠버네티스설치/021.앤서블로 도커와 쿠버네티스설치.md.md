자동화 전문가의 관점에서, **Ansible Playbook**을 이용한 Docker와 Kubernetes(K8s) 설치는 인프라를 일관되고 반복 가능하며 확장성 있게 구축하는 **가장 표준적인 방법**입니다.

Docker 설치는 비교적 간단하지만, K8s 클러스터 구축은 \*\*`kubeadm`\*\*을 기반으로 복잡한 선행 조건과 마스터/워커 노드별 작업을 요구합니다. 이 모든 과정을 하나의 Playbook 세트로 자동화하는 것이 핵심입니다.

### 1\. Ansible 환경 및 사전 준비 사항

Docker와 K8s 설치를 자동화하기 전에 다음 사항이 전제되어야 합니다.

  * **Ansible 컨트롤 노드:** Playbook을 실행할 중앙 서버(SSH 접속 및 Ansible 설치 필수).
  * **관리 대상 노드(Target Nodes):** Docker와 K8s가 설치될 VM 또는 서버. (OS: Ubuntu 또는 CentOS 권장)
  * **SSH 키 기반 인증:** 컨트롤 노드에서 모든 대상 노드로 비밀번호 없이 \*\*`ssh-copy-id`\*\*를 통해 접속 가능해야 합니다. (`ansible_become: yes` 사용 시 sudo 비밀번호 없이 권한 상승 가능)
  * **Inventory 파일 구성:** 마스터 노드와 워커 노드를 명확히 구분하는 그룹 설정이 필요합니다.

<!-- end list -->

```ini
[master]
k8s-master ansible_host=192.168.1.10

[worker]
k8s-worker1 ansible_host=192.168.1.11
k8s-worker2 ansible_host=192.168.1.12

[all:vars]
ansible_user=ubuntu 
ansible_become=yes # sudo 권한 사용
```

-----

### 2\. Playbook을 이용한 Docker 설치 (Container Runtime)

K8s는 \*\*컨테이너 런타임 인터페이스(CRI)\*\*를 필요로 합니다. **Containerd**가 쿠버네티스의 기본 런타임이지만, Docker를 포함하여 설치하는 것이 관리 편의성에서 유리할 수 있습니다.

**`docker-install.yml`** (모든 노드에서 실행)

```yaml
---
- name: 🚀 Install Docker (Container Runtime for K8s)
  hosts: all
  become: yes
  tasks:
    # 1. 시스템 업데이트 및 필수 패키지 설치
    - name: Update apt cache and install prerequisites
      ansible.builtin.apt:
        name: 
          - apt-transport-https
          - ca-certificates
          - curl
          - software-properties-common
        state: present
        update_cache: yes

    # 2. Docker GPG 키 및 Repository 추가
    - name: Add Docker GPG apt Key
      ansible.builtin.apt_key:
        url: https://download.docker.com/linux/ubuntu/gpg
        state: present
        
    - name: Add Docker Repository
      ansible.builtin.apt_repository:
        repo: deb [arch=amd64] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable
        state: present
        
    # 3. Docker Engine 및 관련 패키지 설치 (containd.io 포함)
    - name: Install Docker Packages
      ansible.builtin.apt:
        name: 
          - docker-ce
          - docker-ce-cli
          - containerd.io
        state: present

    # 4. 일반 사용자에게 Docker 권한 부여
    - name: Add user to docker group
      ansible.builtin.user:
        name: "{{ ansible_user }}"
        groups: docker
        append: yes
```

-----

### 3\. Playbook을 이용한 Kubernetes 설치 (kubeadm 기반)

쿠버네티스 설치는 **스왑 비활성화, 네트워크 설정, Kube-tools 설치, 클러스터 초기화**의 4단계로 나뉩니다.

#### A. Pre-requisite Playbook (`k8s-prep.yml`)

K8s 설치를 위한 선행 조건(모든 노드에서 필수)을 설정합니다.

```yaml
---
- name: ⚙️ Kubernetes Pre-requisites Setup
  hosts: all
  become: yes
  tasks:
    # 1. Swap 메모리 비활성화 (Kubelet 요구 사항)
    - name: Disable swap permanently (comment out fstab entry)
      ansible.builtin.replace:
        path: /etc/fstab
        regexp: '^(\s*)([^#]+\s+swap\s+sw\s+.*)$'
        replace: '#\2'
        
    - name: Turn off swap immediately
      ansible.builtin.command: swapoff -a
      when: ansible_swaptotal_mb > 0

    # 2. 브릿지 네트워크 트래픽에 대한 iptables 확인 설정 (K8s 네트워킹 필수)
    - name: Configure sysctl for Kubernetes networking
      ansible.builtin.sysctl:
        name: "{{ item }}"
        value: '1'
        state: present
        reload: yes
      loop:
        - net.bridge.bridge-nf-call-iptables
        - net.bridge.bridge-nf-call-ip6tables
        - net.ipv4.ip_forward
        
    # 3. Kubernetes Tools 설치 (kubeadm, kubelet, kubectl)
    - name: Add Kubernetes GPG Key
      ansible.builtin.apt_key:
        url: https://packages.cloud.google.com/apt/doc/apt-key.gpg
        state: present

    - name: Add Kubernetes Repository
      ansible.builtin.apt_repository:
        repo: deb https://apt.kubernetes.io/ kubernetes-xenial main
        state: present
        filename: kubernetes
        
    - name: Install kubelet, kubeadm, kubectl and hold their versions
      ansible.builtin.apt:
        name: 
          - kubelet={{ kube_version }}
          - kubeadm={{ kube_version }}
          - kubectl={{ kube_version }}
        state: present
        update_cache: yes

    - name: Mark K8s packages to hold (prevent accidental upgrade)
      ansible.builtin.dpkg_selections:
        name: "{{ item }}"
        selection: hold
      loop:
        - kubelet
        - kubeadm
        - kubectl
```

#### B. Master Node 초기화 (`k8s-master-init.yml`)

마스터 노드에서 클러스터를 초기화하고 워커 노드가 조인할 토큰을 생성합니다.

```yaml
---
- name: 👑 Initialize Kubernetes Master Node
  hosts: master
  become: yes
  vars:
    # 예: 원하는 K8s 버전 (Playbook 실행 시 --extra-vars "kube_version=1.29.0-00" 로 변경 가능)
    kube_version: "1.29.0-00" 
    pod_network_cidr: "10.244.0.0/16" # Calico CNI 표준 CIDR
  tasks:
    - name: Initialize the Kubernetes Cluster (kubeadm init)
      ansible.builtin.command: >
        kubeadm init 
        --pod-network-cidr={{ pod_network_cidr }} 
        --ignore-preflight-errors=NumCPU
      register: kubeadm_init_result # 결과 저장

    - name: Create .kube directory for cluster config
      ansible.builtin.file:
        path: /home/{{ ansible_user }}/.kube
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'
        
    - name: Copy admin.conf to user's .kube directory
      ansible.builtin.copy:
        src: /etc/kubernetes/admin.conf
        dest: /home/{{ ansible_user }}/.kube/config
        remote_src: yes
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0600'

    # Flannel CNI 설치 (네트워크 플러그인)
    - name: Install Flannel CNI Network Plugin
      ansible.builtin.command: >
        kubectl apply -f https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml

    # 워커 노드 조인 명령 생성 (토큰 추출)
    - name: Generate join command for worker nodes
      ansible.builtin.command: >
        kubeadm token create --print-join-command
      register: join_command_result
    
    - name: Display join command
      ansible.builtin.debug:
        msg: "Worker Join Command: {{ join_command_result.stdout }}"
      delegate_to: localhost # 결과를 컨트롤 노드 터미널에 출력
```



마스터노드에서 토큰 생성하기
```
$kubeadm token create --print-join-command
kubeadm join 192.168.100.251:6443 --token vk4bw9.d08sgu4kuosddhuc --discovery-token-ca-cert-hash sha256:65fd5196d5da8d15de93cdd30fdfbca1bd4787e226ead36c5860bcf2124c7df3
# 결과값이 나오면 메모장을 열어서 복사해 둡니다. 
```


#### C. Worker Node 조인 (`k8s-worker-join.yml`)

워커 노드를 클러스터에 합류시킵니다. (마스터 노드에서 얻은 토큰 사용)


```yaml
---
- name: 🤝 Join Worker Nodes to Cluster
  hosts: worker
  become: yes
  tasks:
    # Master Playbook에서 생성된 토큰을 복사하여 실행
    - name: Execute join command on worker nodes
      ansible.builtin.shell: 
        cmd: "kubeadm join 192.168.100.251:6443 --token vk4bw9.d08sgu4kuosddhuc --discovery-token-ca-cert-hash sha256:65fd5196d5da8d15de93cdd30fdfbca1bd4787e226ead36c5860bcf2124c7df3"
      register: join_output
      changed_when: join_output.rc == 0
```

-----

### 4\. 실행 순서 및 마무리

Playbook은 순서대로 실행해야 합니다.

1.  **Docker 설치:**
    ```bash
    ansible-playbook docker-install.yml -i inventory
    ```
2.  **K8s 사전 준비:**
    ```bash
    ansible-playbook k8s-prep.yml -i inventory
    ```
3.  **마스터 노드 초기화:**
    ```bash
    ansible-playbook k8s-master-init.yml -i inventory
    ```
4.  **워커 노드 조인:**
    ```bash
    ansible-playbook k8s-worker-join.yml -i inventory
    ```

**최종 확인:** 마스터 노드에서 다음 명령을 실행하여 모든 노드가 **`Ready`** 상태인지 확인합니다.

```bash
kubectl get nodes
```

이 자동화된 접근 방식은 DevOps 환경에서 가장 효율적인 클러스터 구축 방법이며, 필요 시 **Kubespray**와 같은 전문적인 Ansible 기반 K8s 설치 도구를 사용하는 것을 고려해 볼 수 있습니다.
---## Kubernetes 마스터 노드 자기 자신(Self) 할당 가이드

네, **마스터 노드에서 자기 자신을 대상으로 Ansible Playbook을 실행하는 것은 기술적으로 가능하며, 실습 환경에서는 매우 일반적인 방식**입니다.

다만, 원격 PC를 제어할 때와는 몇 가지 설정 차이가 있으므로 이를 정확히 이해하고 반영해야 합니다.

---

### 1. 자기 자신을 제어할 때의 Inventory 설정

Ansible 컨트롤 노드(명령을 내리는 PC)가 동시에 Kubernetes 마스터 노드가 될 경우, `inventory` 파일에서 `ansible_connection=local` 설정을 사용하는 것이 효율적입니다.

#### 수정된 `inventory` 예시

```ini
[master]
# 자기 자신을 가리킬 때 'localhost'와 'local' 연결 방식 사용
localhost ansible_connection=local

[worker]
k8s-worker1 ansible_host=192.168.0.101
k8s-worker2 ansible_host=192.168.0.102

[all:vars]
ansible_user=master
ansible_become=yes

```

---

### 2. 자기 자신(Localhost) 실행 시 주의사항

1. **SSH 키 생략 가능:** `ansible_connection=local`을 사용하면 SSH 프로토콜을 거치지 않고 직접 내부 쉘 명령을 실행합니다. 따라서 자기 자신에 대해 `ssh-copy-id`를 할 필요가 없습니다.
2. **권한 상승(Become):** 로컬 실행이라 하더라도 K8s 설치는 루트 권한이 필요합니다. 실행 시 `sudo` 비밀번호를 묻지 않도록 설정하거나, 실행 명령에 `-K` 옵션을 추가해야 합니다.
* `ansible-playbook -i inventory site.yml -K`


3. **IP 주소 바인딩:** `kubeadm init` 실행 시 `--apiserver-advertise-address` 옵션을 명시하는 것이 좋습니다. `localhost`로 실행하더라도 클러스터는 외부(워커 노드)와 통신해야 하므로 **루프백(127.0.0.1)이 아닌 실제 사설 IP**를 지정해야 합니다.

---

### 3. Playbook 수정 제안 (`k8s-master-init.yml`)

자기 자신을 마스터로 잡을 때, IP 주소를 동적으로 할당받아 초기화하도록 태스크를 보강하면 더욱 안정적입니다.

```yaml
    - name: Initialize the Kubernetes Cluster
      ansible.builtin.command: >
        kubeadm init 
        --pod-network-cidr={{ pod_network_cidr }} 
        --apiserver-advertise-address={{ ansible_default_ipv4.address }}
        --ignore-preflight-errors=NumCPU

```

---

### 4. 장단점 요약

| 구분 | 장점 | 단점/주의사항 |
| --- | --- | --- |
| **자기 자신(Local)** | 별도의 마스터 VM이 필요 없어 자원이 절약됨. SSH 설정 불필요. | 컨트롤 노드 문제 발생 시 클러스터 전체 관리 불능. |
| **원격 마스터(Remote)** | 실제 운영 환경과 가장 유사함. 역할 분리가 명확함. | 마스터 전용 VM 사양이 추가로 필요함(최소 2개 CPU, 2GB RAM). |

---

### 결론: 실습용으로는 "YES"

현재 진행 중인 교재 프로젝트에서는 **마스터 서버(컨트롤 노드)가 스스로 마스터 노드 역할을 수행**하도록 구성하는 것이 리소스 효율성 면에서 매우 좋은 선택입니다. 위에서 언급한 `ansible_connection=local` 방식과 실제 IP 바인딩 주소만 신경 쓰시면 문제없이 작동합니다.

Next Step: 마스터 노드 자기 자신 할당 시 발생할 수 있는 'localhost' 통신 오류 해결 방법
