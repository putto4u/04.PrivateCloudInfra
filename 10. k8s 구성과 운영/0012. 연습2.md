수강생들이 터미널에서 명령어를 입력했을 때 어떤 화면이 출력되어야 정상인지 한눈에 파악할 수 있도록, **[확인 방법 및 결과 예시]**를 통합하여 프롬프트 박스 형태로 정리해 드립니다.

---

## 📘 Docker & Docker Compose 실습 정답 및 상세 해설 (통합본)

### [Part 1: Docker 기초 명령어]

**1. 이미지 검색**

* **정답:** `docker search mysql`
* **해석:** Docker Hub 저장소에서 'mysql'이라는 키워드가 포함된 이미지를 검색합니다.

```bash
# 확인 방법 및 결과 예시
$ docker search mysql --filter "is-official=true"

NAME      DESCRIPTION                                     STARS     OFFICIAL
mysql     MySQL is a widely used, open-source relati...   14201     [OK]
mariadb   MariaDB Server is a high performing, open ...   5600      [OK]

```

**2. 이미지 다운로드**

* **정답:** `docker pull mysql:8.0`
* **해석:** 특정 버전(8.0)의 MySQL 이미지를 로컬로 가져옵니다.

```bash
# 확인 방법 및 결과 예시
$ docker pull mysql:8.0

8.0: Pulling from library/mysql
Digest: sha256:ae5276...
Status: Downloaded newer image for mysql:8.0

```

**3. 목록 확인**

* **정답:** `docker images`
* **해석:** 내 PC에 저장된 이미지 리스트를 확인합니다.

```bash
# 확인 방법 및 결과 예시
$ docker images

REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
mysql        8.0       c8065edef691   2 weeks ago   448MB
nginx        latest    605c77e624dd   3 weeks ago   141MB

```

**4. 컨테이너 생성 및 실행**

* **정답:** `docker run -d --name web-server -p 8080:80 nginx`
* **해석:** 백그라운드에서 `web-server`라는 이름으로 8080 포트를 연결해 실행합니다.

```bash
# 확인 방법 및 결과 예시
$ docker ps

CONTAINER ID   IMAGE   COMMAND                  STATUS         PORTS                  NAMES
a1b2c3d4e5f6   nginx   "/docker-entrypoint.…"   Up 5 seconds   0.0.0.0:8080->80/tcp   web-server

```

**5. 컨테이너 내부 진입**

* **정답:** `docker exec -it web-server bash`
* **해석:** 실행 중인 컨테이너 내부의 리눅스 터미널에 접속합니다.

```bash
# 확인 방법 및 결과 예시
$ docker exec -it web-server bash

root@a1b2c3d4e5f6:/# ls
bin  boot  dev  docker-entrypoint.d  etc  home  lib  media  mnt  opt ...
root@a1b2c3d4e5f6:/# exit

```

---

### [Part 2: Dockerfile 및 빌드]

**6. 이미지 빌드**

* **정답:** `docker build -t my-app:v1 .`
* **해석:** 현재 디렉토리(`.`)의 Dockerfile을 읽어 `my-app:v1` 이미지를 생성합니다.

```bash
# 확인 방법 및 결과 예시
$ docker build -t my-app:v1 .

[+] Building 1.2s (8/8) FINISHED
 => [internal] load build definition from Dockerfile
 => [internal] load .dockerignore
 => [1/3] FROM python:3.9-slim
 => [2/3] COPY . /app
 => [3/3] RUN pip install -r requirements.txt
 => exporting to image
 => NAMING my-app:v1

```

---

### [Part 3: Docker Compose 및 볼륨]

**7. 컴포즈 실행**

* **정답:** `docker-compose up -d`
* **해석:** `docker-compose.yml` 설계도에 정의된 모든 서비스를 일괄 실행합니다.

```bash
# 확인 방법 및 결과 예시
$ docker-compose up -d

[+] Running 3/3
 ⠿ Network project_default  Created
 ⠿ Container db-server      Started
 ⠿ Container web-app        Started

```

**8. 로그 실시간 확인**

* **정답:** `docker-compose logs -f`
* **해석:** 컴포즈로 실행된 모든 서비스의 로그를 실시간으로 모니터링합니다.

```bash
# 확인 방법 및 결과 예시
$ docker-compose logs -f

db-server  | 2026-01-28 14:00:00 [Note] [Entrypoint]: Ready for connections.
web-app    |  * Serving Flask app 'app'
web-app    |  * Debug mode: off
web-app    |  * Running on all addresses (0.0.0.0)

```

---

### 🏗️ 상세 이론 및 구조 설명

#### 1. 컨테이너 레이어 시스템 (Layered File System)

도커 이미지는 여러 개의 **읽기 전용(Read-only) 레이어**가 쌓인 형태입니다. `COPY`나 `RUN` 명령어가 실행될 때마다 새로운 레이어가 생성됩니다. 컨테이너를 실행하면 그 위에 **읽기/쓰기(Read-Write) 레이어**가 얇게 얹어지며, 우리가 컨테이너 안에서 파일을 만들거나 수정하는 것은 모두 이 최상단 레이어에서 일어납니다.

#### 2. 포트 포워딩 (Port Forwarding) 구조

호스트 IP의 특정 포트로 들어온 패킷을 컨테이너 내부 IP의 포트로 전달하는 기술입니다.

* **호스트(Host):** 실제 물리 서버나 여러분의 PC (예: 8080)
* **컨테이너(Container):** 격리된 가상 공간 (예: 80)
* 사용자는 `http://localhost:8080`으로 접속하지만, 실제 데이터는 컨테이너 내부의 `80`번 포트에서 처리됩니다.

---

### **Next Step:**

도커 볼륨(Volume)과 바인드 마운트(Bind Mount)의 차이점 정리하기
