쿠버네티스 클러스터 구축을 축하드립니다! 이제 **마스터 PC(Master)**에서 명령을 내리면, 쿠버네티스 컨트롤러가 **예비서버(Worker Nodes)**인 vm1과 vm2에 파드를 골고루 배포하게 됩니다.

직접 파드를 생성하지 않고, 관리 도구인 **Deployment**를 통해 Nginx 파드 2대를 유지하고 외부에서 접속하는 전체 과정을 정리해 드립니다.

---

### **1. Nginx 배포를 위한 Deployment YAML 작성**

먼저 파드 2대를 유지하고 관리할 `deployment.yaml` 파일을 생성합니다.

```yaml
apiVersion: apps/v1             # Deployment 객체의 API 버전
kind: Deployment                # 객체 종류: 디플로이먼트
metadata:
  name: nginx-deployment        # 디플로이먼트의 이름
spec:
  replicas: 2                   # 유지할 파드(Pod)의 개수 (엔진x 2대)
  selector:                     # 어떤 파드를 관리할지 결정하는 조건
    matchLabels:
      app: nginx-web            # app: nginx-web 라벨이 붙은 파드를 관리
  template:                     # 실제 생성될 파드의 모양(템플릿)
    metadata:
      labels:
        app: nginx-web          # 생성될 파드에 부여할 라벨
    spec:
      containers:               # 파드 안의 컨테이너 설정
      - name: nginx             # 컨테이너 이름
        image: nginx:latest     # 사용할 엔진x 이미지
        ports:
        - containerPort: 80     # 컨테이너가 사용하는 포트

```

### **2. 외부 접속을 위한 Service YAML 작성**

파드는 유동적이라 IP가 변합니다. 이를 묶어서 하나의 접속 지점을 만들어주는 `service.yaml`을 생성합니다. 여기서는 별도의 로드밸런서 없이 워커노드의 포트를 직접 여는 `NodePort` 방식을 사용합니다.

```yaml
apiVersion: v1
kind: Service                   # 객체 종류: 서비스
metadata:
  name: nginx-service           # 서비스 이름
spec:
  selector:                     # 서비스가 트래픽을 전달할 대상 파드 지정
    app: nginx-web              # 위 Deployment에서 정의한 라벨과 일치해야 함
  ports:
    - protocol: TCP
      port: 80                  # 서비스 자체의 포트
      targetPort: 80            # 파드(컨테이너) 내부의 포트
      nodePort: 30080           # 워커노드 IP로 접속할 때 사용할 외부 포트 (30000-32767 사이)
  type: NodePort                # 서비스 타입 (NodePort는 노드의 IP를 통해 외부 접속 허용)

```

---

### **3. 실행 및 확인 절차 (명령줄)**

마스터 PC의 터미널에서 아래 명령어를 순서대로 입력하세요.

```bash
# 1. 디플로이먼트 생성 (파드 2대 자동 생성)
kubectl apply -f deployment.yaml

# 2. 서비스 생성 (외부 접속 통로 개설)
kubectl apply -f service.yaml

# 3. 배포 상태 확인 (READY가 2/2인지 확인)
kubectl get deployments

# 4. 파드가 어떤 노드(vm1, vm2)에 배포되었는지 확인
kubectl get pods -o wide

# 5. 서비스 상태 및 포트 확인
kubectl get service

```

### **4. 최종 접속 확인 방법**

이제 웹 브라우저를 열고 다음 주소 중 하나로 접속해 보세요.

* `http://[vm1의-IP]:30080`
* `http://[vm2의-IP]:30080`

쿠버네티스 서비스가 내부적으로 로드밸런싱을 해주기 때문에, 어떤 워커노드의 IP로 접속하더라도 정상적으로 Nginx 화면이 나타납니다.

---

### **핵심 설명 및 주의사항**

1. **자동 복구(Self-healing)**: 만약 `kubectl delete pod [파드이름]` 명령어로 파드 하나를 강제로 삭제해 보세요. 디플로이먼트가 `replicas: 2`를 유지하기 위해 즉시 새로운 파드를 다시 생성하는 것을 볼 수 있습니다.
2. **스케줄링**: 마스터 PC의 스케줄러는 vm1과 vm2의 자원 상태를 보고 파드를 적절히 분배합니다. `get pods -o wide` 명령어로 분배 현황을 확인하세요.
3. **비용 관련**: 현재는 VM 환경이므로 추가 비용이 없으나, 만약 이 설정을 **AWS EKS**에서 실행하고 `type: LoadBalancer`로 변경하면 **AWS ELB 요금**이 발생하게 됩니다. 현재의 `NodePort`는 별도 비용이 들지 않는 방식입니다.

**Next Step: 쿠버네티스 업데이트와 롤링 업데이트 전략**

* 이미지 버전을 변경했을 때 서비스 중단 없이 파드가 교체되는 과정을 학습할 예정입니다.
* 위 절차 중 에러가 발생하는 부분이 있다면 해당 에러 메시지를 알려주세요. 수정해 드리겠습니다.
