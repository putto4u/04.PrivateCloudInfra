리플리카셋(ReplicaSet)은 쿠버네티스에서 **파드(Pod)의 개수를 유지**해 주는 핵심 오브젝트입니다. 단순히 파드를 생성하는 것을 넘어, 클러스터 내에서 지정된 수의 파드가 항상 안정적으로 실행되도록 보장하는 '감시자' 역할을 수행합니다.

---

## 1. 리플리카셋의 핵심 역할

리플리카셋은 사용자로부터 전달받은 **의도한 상태(Desired State)**를 유지하기 위해 다음과 같은 일을 수행합니다.

* **자가 치유 (Self-Healing):** 파드가 어떤 이유로 종료되거나 노드 장애가 발생하면, 리플리카셋은 즉시 새로운 파드를 생성하여 설정된 개수를 맞춥니다.
* **규모 조절 (Scaling):** YAML 파일의 `replicas` 수치를 변경하는 것만으로 실행 중인 파드의 개수를 늘리거나 줄일 수 있습니다.
* **레이블 기반 관리:** 특정 레이블(Label)을 가진 파드들을 감시하며, 부족하면 생성하고 넘치면 삭제합니다.

## 2. 리플리카셋의 주요 구성 요소 (3가지)

리플리카셋을 정의할 때는 반드시 다음 세 가지 항목이 포함되어야 합니다.

1. **셀렉터 (Selector):** 리플리카셋이 어떤 파드들을 관리할지 결정하는 기준입니다. (레이블 체크)
2. **복제본 수 (Replicas):** 유지해야 할 파드의 총 개수입니다.
3. **파드 템플릿 (Pod Template):** 파드가 부족하여 새로 만들어야 할 때, 어떤 사양(이미지, 포트 등)으로 만들지 정의한 설계도입니다.

## 3. 디플로이먼트(Deployment)와의 차이점

현업에서는 리플리카셋을 직접 생성하기보다는 **디플로이먼트(Deployment)**를 통해 간접적으로 관리하는 것을 권장합니다.

| 구분 | ReplicaSet | Deployment |
| --- | --- | --- |
| **주요 목적** | 파드 개수 유지 | 애플리케이션의 배포 및 업데이트 |
| **버전 관리** | 지원 안 함 (수동 변경 필요) | **롤링 업데이트(Rolling Update)** 지원 |
| **롤백** | 불가능 | **이전 버전으로 복구(Rollback)** 지원 |

> **실전 팁:** 디플로이먼트를 생성하면 리플리카셋은 자동으로 생성됩니다. 만약 애플리케이션을 업데이트하면 디플로이먼트는 새로운 리플리카셋을 만들고, 기존 리플리카셋의 파드 수를 서서히 줄이며 교체 작업을 진행합니다.

---

## 4. 인프라 운영 및 비용 고려 사항 (AWS 환경)

리플리카셋의 설정값은 물리적인 자원 할당과 직결되므로 주의가 필요합니다.

* **EC2 인스턴스 용량:** `replicas` 수를 과도하게 높이면 워커 노드(EC2)의 CPU/메모리 자원이 부족해져 파드가 `Pending` 상태에 빠질 수 있습니다.
* **Cluster Autoscaler 연동:** AWS EKS 사용 시, 리플리카셋의 요구 사항을 감당하지 못하면 **Cluster Autoscaler**가 새 EC2 인스턴스를 자동으로 추가 생성하며, 이때 **추가적인 EC2 비용**이 발생합니다.
* **네트워크 대역폭:** 파드 개수가 늘어나면 각 파드에 할당되는 **Private IP(AWS VPC CNI 기준)** 소모가 커지며, 인스턴스 타입에 따라 할당 가능한 최대 IP 개수 제한에 걸릴 수 있습니다.

---

Next Step: 리플리카셋 YAML 파일의 selector와 label 매칭 원리 실습

네, 리플리카셋(ReplicaSet)은 디플로이먼트와 독립적으로 존재하는 **독자적인 오브젝트**이기 때문에 디플로이먼트 없이 단독으로 실행이 가능합니다.

---

## 1. 단독 실행 가능 여부

쿠버네티스 아키텍처 상 리플리카셋은 스스로 파드를 감시하고 개수를 유지하는 로직을 가지고 있습니다. 따라서 디플로이먼트라는 상위 관리자 없이도 YAML 파일을 작성하여 직접 클러스터에 배포할 수 있습니다.

### 리플리카셋 단독 실행 시 흐름

1. `kind: ReplicaSet`으로 정의된 YAML 파일 작성
2. `kubectl apply -f [파일명].yaml` 실행
3. 리플리카셋 컨트롤러가 정의된 `replicas` 수만큼 파드를 생성 및 유지

## 2. 왜 실무에서는 디플로이먼트를 쓰는가?

리플리카셋을 단독으로 실행하면 **"개수 유지"**는 완벽하게 수행하지만, **"업데이트"** 단계에서 큰 불편함이 발생합니다.

* **리플리카셋 단독 사용 시:** 컨테이너 이미지를 업데이트하려면 기존 리플리카셋을 삭제하고 새 리플리카셋을 만들거나, 실행 중인 파드들을 수동으로 삭제하여 새 템플릿으로 재생성되게 유도해야 합니다.
* **디플로이먼트 사용 시:** 디플로이먼트가 내부적으로 '기존 리플리카셋'의 파드 수는 줄이고, '새 버전 리플리카셋'의 파드 수는 늘리는 **배포 전략(Rolling Update)**을 자동으로 수행합니다.

## 3. 리플리카셋과 파드의 연결 고리 (Selector)

리플리카셋이 디플로이먼트 없이도 파드를 관리할 수 있는 이유는 `selector`와 `label` 덕분입니다. 리플리카셋은 클러스터 내의 파드들 중 자신의 셀렉터 조건과 일치하는 레이블을 가진 파드가 있는지만 확인합니다.

> **실전 팁:** 만약 리플리카셋이 없는 상태에서 특정 레이블을 가진 파드가 이미 실행 중이라면, 나중에 그 레이블을 셀렉터로 가진 리플리카셋을 실행했을 때 리플리카셋은 해당 파드를 **자신의 관리 대상**으로 즉시 편입시킵니다.

---

## 4. 운영 및 비용 관련 (AWS EKS 환경)

리플리카셋을 단독으로 쓰든 디플로이먼트로 쓰든 AWS 자원 소모 측면에서는 차이가 없으나, 운영 효율성 면에서 다음을 고려해야 합니다.

* **배포 사고 비용:** 리플리카셋 단독 운영 중 업데이트 실수로 서비스가 중단(Downtime)되면 비즈니스 손실이 발생할 수 있습니다. 디플로이먼트의 **Rollback** 기능을 활용하는 것이 운영 안정성 측면에서 훨씬 경제적입니다.
* **리소스 낭비 방지:** EKS에서 테스트 용도로 리플리카셋을 단독 실행한 후 삭제하는 것을 잊으면, 지정된 `replicas`만큼 EC2 인스턴스 자원을 계속 점유하여 불필요한 비용이 발생합니다.

---

Next Step: 리플리카셋 단독 실행 YAML 예제 및 파드 레이블 매칭 테스트

강의 교재의 깊이를 더하기 위해 리플리카셋의 독립성을 설명해 드렸습니다. 직접 실행해 볼 수 있는 간단한 YAML 코드가 필요하시면 말씀해 주세요.
