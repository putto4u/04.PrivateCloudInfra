쿠버네티스 디플로이먼트(Deployment)를 YAML 파일 없이 명령줄에서 즉시 생성하고 관리하는 **명령형(Imperative)** 방식의 실전 예제들을 정리해 드립니다. 
## 디플로이먼트(Deployment)의 이해와 상세 분석

디플로이먼트는 쿠버네티스에서 **상태가 없는(Stateless) 애플리케이션**을 배포할 때 사용하는 가장 표준적인 오브젝트입니다. 단순히 Pod를 실행하는 것을 넘어, 애플리케이션의 **버전 관리, 복제본 유지, 무중단 업데이트**를 자동화하는 핵심 컨트롤러입니다.

---

### 1. 디플로이먼트의 계층 구조

디플로이먼트는 직접 Pod를 생성하지 않고, **레플리카셋(ReplicaSet)**을 거쳐 Pod를 관리하는 3계층 구조를 가집니다.

* **Deployment**: 배포 전략(RollingUpdate 등)과 이미지 버전을 관리합니다.
* **ReplicaSet**: 지정된 수(Replicas)의 Pod가 항상 실행되도록 보장합니다.
* **Pod**: 실제 컨테이너가 실행되는 최소 단위입니다.


디플로이먼트 계층 구조 YAML 예시

```YAML
apiVersion: apps/v1             # 1. API 그룹 및 버전 정의
kind: Deployment                # 2. 리소스의 종류가 디플로이먼트임을 명시
metadata:                       # 3. 디플로이먼트 자체의 메타데이터
  name: nginx-deployment        #    - 디플로이먼트의 이름
  labels:                       #    - 관리 편의를 위한 이름표
    app: nginx
spec:                           # 4. [Deployment 계층] 상세 명세 시작
  replicas: 3                   #    - [ReplicaSet 계층] 유지할 포드(Pod)의 개수 설정
  selector:                     #    - [ReplicaSet 계층] 관리할 포드를 식별하는 조건
    matchLabels:                #      * 아래 template의 labels와 반드시 일치해야 함
      app: nginx
  template:                     # 5. [Pod 계층] 생성될 포드의 설계도 (Pod Template)
    metadata:                   #    - 포드의 메타데이터
      labels:                   #      * ReplicaSet이 이 라벨을 보고 포드를 관리함
        app: nginx
    spec:                       # 6. [Pod 계층] 포드 내부 컨테이너 상세 설정
      containers:               #    - 컨테이너 리스트
      - name: nginx             #      * 컨테이너 이름 정의
        image: nginx:1.14.2     #      * 사용할 도커 이미지 및 버전
        ports:                  #      * 네트워크 포트 설정
        - containerPort: 80     #        - 컨테이너가 사용할 포트 번호
```
---

### 2. 주요 핵심 기능

1. **자가 치유 (Self-Healing)**: 노드 장애나 프로세스 종료로 Pod가 삭제되면, 디플로이먼트는 즉시 새로운 Pod를 생성하여 선언된 복제본 수를 유지합니다.
2. **무중단 업데이트 (Rolling Update)**: 서비스 중단 없이 새 버전의 이미지를 점진적으로 교체합니다.
3. **배포 이력 및 롤백 (Rollback)**: 배포 이력을 리비전(Revision) 단위로 저장하여, 문제 발생 시 즉시 이전 버전으로 되돌릴 수 있습니다.
4. **확장성 (Scaling)**: 명령어 한 줄로 Pod의 개수를 자유롭게 늘리거나 줄일 수 있습니다.

---

### 3. 디플로이먼트 업데이트 전략

| 전략명 | 동작 방식 | 장점 | 단점 |
| --- | --- | --- | --- |
| **RollingUpdate** | 기존 Pod를 하나씩 제거하며 새 Pod를 하나씩 생성 (기본값) | 서비스 가용성 유지 (Zero Downtime) | 업데이트 중 신/구 버전 공존 |
| **Recreate** | 기존 Pod를 모두 삭제한 후 새 Pod를 생성 | 신/구 버전 간 데이터 충돌 방지 | 업데이트 동안 일시적 서비스 중단 |

---

### 💡 실무 전문가의 팁: Selector 주의사항

디플로이먼트의 `spec.selector`와 `spec.template.metadata.labels`는 반드시 일치해야 합니다. 만약 이 두 설정이 다르면 디플로이먼트가 자기가 만든 Pod를 찾지 못해 무한히 새로운 Pod를 생성하는 무한 루프에 빠질 수 있습니다.

---

### ⚠️ 비용 및 유료 전환 주의사항

* **리소스 과금**: `replicas` 수를 늘리면 워커 노드의 CPU/Memory 자원을 소모합니다. AWS EKS 환경에서 **Cluster Autoscaler**가 활성화된 경우, 자원 부족 시 새 EC2 인스턴스가 자동 생성되어 **인스턴스 비용이 추가 청구**됩니다.
* **LoadBalancer 비용**: `kubectl expose deployment`를 통해 서비스를 LoadBalancer 타입으로 생성하면, AWS 상에서 즉시 **Classic ELB 또는 NLB가 생성**되어 시간당 이용료 및 데이터 처리 비용이 발생합니다.

---

**Next Step: 디플로이먼트 배포 이력 확인 및 Undo(롤백) 실습**

Next Step: **rollout history 조회** | **특정 리비전으로 롤백 실행** | **배포 일시 중지 및 재개**
---

## 1. 디플로이먼트 기본 생성 및 관리

가장 빈번하게 사용되는 디플로이먼트 생성 및 스케일링 예제입니다.

| 작업 내용 | 실전 명령어 예제 | 비고 |
| --- | --- | --- |
| **기본 생성** | `k create deploy web-deploy --image=nginx` | 레플리카 1개로 생성 |
| **복제본 지정 생성** | `k create deploy web-app --image=nginx --replicas=3` | 처음부터 3개로 시작 |
| **포트 지정 생성** | `k create deploy api-server --image=node:16 --port=8080` | 컨테이너 포트 8080 노출 |
| **스케일링 (확장/축소)** | `k scale deploy web-app --replicas=5` | 실행 중인 개수를 5개로 변경 |
| **이미지 업데이트** | `k set image deploy/web-app nginx=nginx:1.21` | 무중단 롤링 업데이트 시작 |

---

## 2. 전문가의 "치트키": Dry-run 활용

**실무에서는 명령형으로 생성하기보다, 명령형으로 **YAML 뼈대(Template)**를 뽑아낸 뒤 수정하여 `apply` 하는 방식을 가장 많이 씁니다.**

* **YAML 템플릿 즉시 생성 및 파일 저장:**
```bash
# 실제로 생성하지 않고 YAML 형식만 화면에 출력
kubectl create deploy my-web --image=nginx --replicas=3 --dry-run=client -o yaml > my-web.yaml

```





---

## 3. 업데이트 및 롤백 (Rollout) 관리

디플로이먼트의 가장 강력한 기능인 배포 이력 관리를 명령형으로 수행하는 방법입니다.

| 작업 내용 | 실전 명령어 예제 | 비고 |
| --- | --- | --- |
| **배포 상태 확인** | `k rollout status deploy/web-app` | 업데이트 완료 여부 모니터링 |
| **배포 이력 확인** | `k rollout history deploy/web-app` | 과거 버전(Revision) 목록 조회 |
| **이전 버전 롤백** | `k rollout undo deploy/web-app` | 바로 직전 버전으로 되돌리기 |
| **특정 버전 롤백** | `k rollout undo deploy/web-app --to-revision=2` | 2번 리비전으로 강제 복구 |
| **배포 일시 정지** | `k rollout pause deploy/web-app` | 업데이트를 잠시 멈춤 |
| **배포 다시 시작** | `k rollout resume deploy/web-app` | 멈춘 업데이트를 재개 |

---

## 4. 서비스 노출 (Expose) 연동

디플로이먼트를 생성한 후, 외부나 내부에서 접근할 수 있도록 서비스를 즉시 연결하는 방법입니다.

* **내부용 서비스 생성 (ClusterIP):**
```bash
kubectl expose deploy web-app --port=80 --target-port=80

```


* **외부 노출용 서비스 생성 (NodePort):**
```bash
kubectl expose deploy web-app --port=80 --type=NodePort --name=web-svc-external

```



---

### ⚠️ 비용 및 유료 전환 주의사항

* **리소스 과금:** 명령형으로 `replicas`를 늘리는 즉시 AWS EC2 노드 위에서 Pod가 생성됩니다. 만약 `replicas=100`과 같이 큰 숫자를 입력할 경우 노드 부족 에러가 나거나, **Cluster Autoscaler**가 작동하여 새로운 EC2 인스턴스가 추가로 생성되어 **비용이 급격히 증가**할 수 있습니다.
* **LoadBalancer 비용:** `kubectl expose ... --type=LoadBalancer`를 실행하면 AWS의 경우 즉시 **Classic ELB 또는 NLB가 생성**되어 시간당 이용료가 청구됩니다. 테스트가 끝나면 반드시 `kubectl delete svc [서비스명]`으로 먼저 삭제해야 합니다.

---

**Next Step: 디플로이먼트 전략(RollingUpdate vs Recreate) 상세 설정 및 실습**

명령형으로 빠르게 디플로이먼트를 다루는 핵심 예제들을 정리해 드렸습니다.

Next Step: **롤링 업데이트(Rolling Update) 전략 파라미터(maxSurge, maxUnavailable) 이해하기** | **명령형 예제 퀴즈 생성**
