전문가 모드(Pro)로 전환하여, 실무 수준의 고가용성 인프라 구축 프로젝트를 A to Z까지 완벽하게 가이드해 드리겠습니다. 요청하신 대로 **컨트롤 서버(Control Server)**의 위치 선정부터 전체 자동화 스크립트까지 상세히 기술합니다.

---

## 0. 아키텍처 설계 및 장비 목록 (Blueprint)

### 0.1 컨트롤 서버(메인 서버) 위치 선정 전략

> **판단**: 컨트롤 서버는 **해당 프로젝트 VPC의 퍼블릭 서브넷(Public Subnet)**에 두는 것이 현 단계에서 가장 효율적입니다.

* **이유 1 (접근성)**: 같은 VPC 내부에 있어야 프라이빗 서브넷에 있는 웹/DB 서버에 별도의 복잡한 피어링(Peering) 없이 사설 IP로 직접 접근하여 Ansible 작업을 수행할 수 있습니다.
* **이유 2 (확장성)**: 향후 다른 VPC를 관리해야 한다면, 이 서버를 'Bastion Host' 겸 'Management Server'로 활용하여 VPC Peering만 연결하면 됩니다.
* **역할**: Terraform 실행, Ansible 통제, Bastion Host(점프 서버), Docker 이미지 빌드 등.

### 0.2 전체 인프라 자원 목록 (Inventory)

**네트워크 대역 (VPC CIDR): `10.0.0.0/16**`

| 역할 | 수량 | 호스트명(Tag) | 할당 IP / 접근 방식 | 위치 (Subnet) | 비고 |
| --- | --- | --- | --- | --- | --- |
| **Control Server** | 1대 | `svr-control-main` | **EIP (고정 공인IP)** / 사설 10.0.1.10 | Public Subnet A | 작업 지휘 본부 |
| **Web Server** | 3대 | `svr-web-asg` | 자동 할당 (DHCP) | Private Subnet A/C | Auto Scaling (최소 3대) |
| **DB (Master)** | 1대 | `rds-main-primary` | DNS 엔드포인트 (Writer) | Private DB Subnet A | 쓰기 전용 |
| **DB (Replica)** | 1대 | `rds-main-reader` | DNS 엔드포인트 (Reader) | Private DB Subnet C | 읽기 전용 (자동 생성) |
| **Load Balancer** | 1대 | `alb-web-main` | DNS 이름 (Public) | Public Subnet A/C | 웹 서버 부하 분산 |
| **S3 Bucket** | 3개 | `prj-iac`, `prj-data`, `prj-log` | - | Global | 용도별 분리 |

---

## 1. 컨트롤 서버(Control Server) 구축 가이드

이 서버는 당신이 AWS 콘솔에서 **수동으로 딱 한 번** 생성해야 하는 '최초의 장비'입니다. (t3.small 이상 권장, OS: Ubuntu 22.04 LTS)

### 1.1 컨트롤 서버 필수 프로그램 설치 스크립트

컨트롤 서버에 접속(`ssh ubuntu@공인IP`)하여 아래 내용을 파일(`setup_control.sh`)로 만들고 실행하세요.

**파일명: `setup_control.sh**`

```bash
#!/bin/bash
# 스크립트 실행 중 에러 발생 시 즉시 중단 (안전 장치)
set -e

echo "=== 1. 시스템 업데이트 및 필수 패키지 설치 ==="
sudo apt-get update -y && sudo apt-get upgrade -y
sudo apt-get install -y unzip software-properties-common git curl tree

echo "=== 2. Terraform 설치 (HashiCorp 공식) ==="
# GPG 키 및 저장소 추가
wget -O- https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg
echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
sudo apt-get update && sudo apt-get install terraform -y
terraform -version # 버전 확인

echo "=== 3. Ansible 설치 ==="
sudo add-apt-repository --yes --update ppa:ansible/ansible
sudo apt-get install -y ansible
sudo apt-get install -y python3-pip python3-boto3 # AWS 동적 인벤토리용 라이브러리
ansible --version

echo "=== 4. Docker 설치 (공식 스크립트 활용) ==="
curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh
sudo usermod -aG docker ubuntu # ubuntu 유저에게 도커 실행 권한 부여
# 변경된 그룹 권한을 현재 세션에 적용하려면 로그아웃 후 재접속 필요

echo "=== 5. AWS CLI 설치 ==="
curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
unzip awscliv2.zip
sudo ./aws/install
aws --version

echo "=== [완료] 모든 설치가 끝났습니다. 재접속해주세요. ==="

```

---

## 2. 프로젝트 디렉토리 구조 (Directory Structure)

컨트롤 서버 내에서 아래와 같이 폴더를 생성합니다. (`mkdir -p project-main/{terraform,ansible,scripts}`)

```text
project-main/
├── scripts/
│   └── deploy_all.sh         # [Phase 5] 전체 실행 스크립트
├── terraform/                # [Phase 3] 인프라 구축
│   ├── main.tf               # 메인 리소스 정의
│   ├── variables.tf          # 변수 정의
│   ├── outputs.tf            # 결과값 출력
│   └── user_data.sh          # EC2 최초 실행 스크립트
└── ansible/                  # [Phase 4] 설정 관리
    ├── aws_ec2.yml           # AWS 동적 인벤토리 설정
    ├── roles/
    │   └── web_server/
    │       ├── tasks/
    │       │   └── main.yml  # Nginx/Docker 설치 태스크
    │       └── templates/
    │           └── index.html.j2 # 테스트용 웹 페이지
    └── site.yml              # 메인 플레이북

```

---

## 3. Terraform 파일 작성 (Infrastructure)

**경로: `~/project-main/terraform/**`

### 3.1 `main.tf` (핵심 인프라 코드)

*모든 라인에 주석을 달았습니다.*

```hcl
# 1. AWS 프로바이더 설정
provider "aws" {
  region = "ap-northeast-2" # 서울 리전
}

# 2. VPC 및 네트워크 생성
resource "aws_vpc" "main" {
  cidr_block           = "10.0.0.0/16" # 전체 IP 대역
  enable_dns_hostnames = true          # DNS 호스트네임 활성화 (RDS 접속용)
  tags = { Name = "prj-vpc" }
}

# 가용영역(AZ) A와 C를 사용 (고가용성)
data "aws_availability_zones" "available" { state = "available" }

# 퍼블릭 서브넷 2개 (로드밸런서용)
resource "aws_subnet" "public" {
  count             = 2
  vpc_id            = aws_vpc.main.id
  cidr_block        = "10.0.${count.index + 1}.0/24" # 10.0.1.0/24, 10.0.2.0/24
  availability_zone = data.aws_availability_zones.available.names[count.index]
  map_public_ip_on_launch = true
  tags = { Name = "prj-pub-subnet-${count.index}" }
}

# 프라이빗 서브넷 2개 (웹 서버 및 DB용)
resource "aws_subnet" "private" {
  count             = 2
  vpc_id            = aws_vpc.main.id
  cidr_block        = "10.0.${count.index + 10}.0/24" # 10.0.10.0/24, 10.0.11.0/24
  availability_zone = data.aws_availability_zones.available.names[count.index]
  tags = { Name = "prj-priv-subnet-${count.index}" }
}

# 인터넷 게이트웨이 (외부 통신용)
resource "aws_internet_gateway" "igw" {
  vpc_id = aws_vpc.main.id
  tags = { Name = "prj-igw" }
}

# 라우팅 테이블 (퍼블릭)
resource "aws_route_table" "public" {
  vpc_id = aws_vpc.main.id
  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.igw.id
  }
}
resource "aws_route_table_association" "public" {
  count          = 2
  subnet_id      = aws_subnet.public[count.index].id
  route_table_id = aws_route_table.public.id
}

# NAT 게이트웨이 (프라이빗 서버가 인터넷(S3/Repo)에 접속하기 위함) - 유료 주의!
resource "aws_eip" "nat" { domain = "vpc" }
resource "aws_nat_gateway" "nat" {
  allocation_id = aws_eip.nat.id
  subnet_id     = aws_subnet.public[0].id # 퍼블릭 서브넷에 배치
  tags = { Name = "prj-nat-gw" }
}

# 라우팅 테이블 (프라이빗)
resource "aws_route_table" "private" {
  vpc_id = aws_vpc.main.id
  route {
    cidr_block     = "0.0.0.0/0"
    nat_gateway_id = aws_nat_gateway.nat.id
  }
}
resource "aws_route_table_association" "private" {
  count          = 2
  subnet_id      = aws_subnet.private[count.index].id
  route_table_id = aws_route_table.private.id
}

# 3. 보안 그룹 (Security Groups)
# ALB용 (외부 -> 80)
resource "aws_security_group" "alb_sg" {
  vpc_id = aws_vpc.main.id
  ingress {
    from_port = 80
    to_port   = 80
    protocol  = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
  egress {
    from_port = 0
    to_port   = 0
    protocol  = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

# 웹 서버용 (ALB 및 컨트롤 서버 -> 80, 22)
resource "aws_security_group" "web_sg" {
  vpc_id = aws_vpc.main.id
  ingress {
    from_port       = 80
    to_port         = 80
    protocol        = "tcp"
    security_groups = [aws_security_group.alb_sg.id] # ALB에서만 접근 허용
  }
  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["10.0.0.0/16"] # VPC 내부(컨트롤 서버)에서만 SSH 허용
  }
  egress {
    from_port = 0
    to_port   = 0
    protocol  = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

# DB용 (웹 서버 -> 3306)
resource "aws_security_group" "db_sg" {
  vpc_id = aws_vpc.main.id
  ingress {
    from_port       = 3306
    to_port         = 3306
    protocol        = "tcp"
    security_groups = [aws_security_group.web_sg.id] # 웹 서버에서만 접근 허용
  }
}

# 4. S3 버킷 생성 (이름에 랜덤 문자열 추가 권장)
resource "aws_s3_bucket" "logs" { bucket = "prj-logs-bucket-unique-123" }
resource "aws_s3_bucket" "data" { bucket = "prj-data-bucket-unique-123" }

# 5. RDS (DB) - Multi-AZ
resource "aws_db_subnet_group" "db_subnet" {
  name       = "main-db-subnet"
  subnet_ids = aws_subnet.private[*].id
}

resource "aws_db_instance" "default" {
  identifier             = "rds-main"
  allocated_storage      = 20
  max_allocated_storage  = 100         # 스토리지 오토스케일링 (최대 100GB)
  engine                 = "mysql"
  engine_version         = "8.0"
  instance_class         = "db.t3.micro"
  db_name                = "mydb"
  username               = "admin"
  password               = var.db_password # 변수 처리
  db_subnet_group_name   = aws_db_subnet_group.db_subnet.name
  vpc_security_group_ids = [aws_security_group.db_sg.id]
  multi_az               = true            # 다중 AZ (읽기 복제본 자동 관리 효과)
  skip_final_snapshot    = true            # 실습용이므로 삭제 시 스냅샷 생략
}

# 6. ALB (Load Balancer)
resource "aws_lb" "main" {
  name               = "alb-web-main"
  internal           = false
  load_balancer_type = "application"
  security_groups    = [aws_security_group.alb_sg.id]
  subnets            = aws_subnet.public[*].id
}

resource "aws_lb_target_group" "web" {
  name     = "tg-web-main"
  port     = 80
  protocol = "HTTP"
  vpc_id   = aws_vpc.main.id
  health_check {
    path = "/" # 헬스 체크 경로
  }
}

resource "aws_lb_listener" "front_end" {
  load_balancer_arn = aws_lb.main.arn
  port              = "80"
  protocol          = "HTTP"
  default_action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.web.arn
  }
}

# 7. Auto Scaling Group (ASG) & Launch Template
resource "aws_launch_template" "web" {
  name_prefix   = "lt-web-"
  image_id      = "ami-0c9c942bd7bf113a2" # Ubuntu 22.04 (서울 리전 기준)
  instance_type = "t3.micro"
  key_name      = var.key_name            # SSH 키 페어 이름

  network_interfaces {
    associate_public_ip_address = false   # 프라이빗 서브넷이므로 Public IP 불필요
    security_groups             = [aws_security_group.web_sg.id]
  }

  # 사용자 데이터: 앤서블이 작업하기 편하게 파이썬만 미리 설치
  user_data = base64encode(<<-EOF
              #!/bin/bash
              apt-get update
              apt-get install -y python3
              EOF
  )
}

resource "aws_autoscaling_group" "web" {
  desired_capacity    = 3                 # 목표 수량 3대
  max_size            = 5                 # 최대 5대
  min_size            = 3                 # 최소 3대
  target_group_arns   = [aws_lb_target_group.web.arn]
  vpc_zone_identifier = aws_subnet.private[*].id # 프라이빗 서브넷 배치
  
  launch_template {
    id      = aws_launch_template.web.id
    version = "$Latest"
  }

  tag {
    key                 = "Role"          # 앤서블이 식별할 태그
    value               = "WebServer"
    propagate_at_launch = true
  }
}

```

### 3.2 `variables.tf` (변수 파일)

```hcl
variable "db_password" {
  description = "RDS 데이터베이스 비밀번호"
  type        = string
  sensitive   = true # 로그에 출력되지 않음
}

variable "key_name" {
  description = "AWS EC2 키페어 이름 (사전에 AWS 콘솔에서 생성 필요)"
  type        = string
}

```

### 3.3 `outputs.tf` (결과 출력)

```hcl
output "alb_dns_name" {
  description = "웹 서비스 접속 주소 (로드밸런서)"
  value       = aws_lb.main.dns_name
}

output "db_endpoint" {
  description = "DB 접속 엔드포인트"
  value       = aws_db_instance.default.endpoint
}

```

---

## 4. Ansible 파일 작성 (Configuration)

**경로: `~/project-main/ansible/**`

### 4.1 `aws_ec2.yml` (AWS 동적 인벤토리)

테라폼이 만든 서버들의 IP를 자동으로 찾아오는 설정입니다.

```yaml
plugin: amazon.aws.aws_ec2
regions:
  - ap-northeast-2
filters:
  tag:Role: WebServer        # ASG에서 설정한 태그와 일치하는 서버만 선택
  instance-state-name: running
keyed_groups:
  - key: tags.Role
    prefix: role
hostnames:
  - private-ip-address       # 프라이빗 IP를 호스트명으로 사용

```

### 4.2 `roles/web_server/tasks/main.yml` (웹 서버 설정)

도커를 설치하고 Nginx를 실행하는 태스크입니다.

```yaml
---
- name: Install required system packages
  apt:
    name:
      - apt-transport-https
      - ca-certificates
      - curl
      - software-properties-common
      - python3-pip
      - python3-setuptools
    state: present
    update_cache: yes

- name: Install Docker
  apt:
    name: docker.io
    state: present

- name: Start Docker service
  service:
    name: docker
    state: started
    enabled: yes

- name: Install Docker SDK for Python (Ansible 도커 모듈용)
  pip:
    name: docker

- name: Create Web Page Directory
  file:
    path: /var/www/html
    state: directory
    mode: '0755'

- name: Deploy Dynamic Index Page
  template:
    src: index.html.j2
    dest: /var/www/html/index.html

- name: Run Nginx Container
  community.docker.docker_container:
    name: web_server
    image: nginx:latest
    state: started
    restart_policy: always
    ports:
      - "80:80"
    volumes:
      - /var/www/html:/usr/share/nginx/html:ro # 호스트 파일을 컨테이너에 마운트

```

### 4.3 `roles/web_server/templates/index.html.j2` (웹 페이지 템플릿)

```html
<!DOCTYPE html>
<html>
<head><title>Pro Project</title></head>
<body>
    <h1>Web Server Online</h1>
    <p>Server IP: {{ ansible_default_ipv4.address }}</p>
    <p>Connected DB Endpoint: {{ db_endpoint }}</p> </body>
</html>

```

### 4.4 `site.yml` (메인 플레이북)

```yaml
---
- name: Configure Web Servers
  hosts: role_WebServer     # 동적 인벤토리 그룹명
  become: yes               # root 권한 실행
  user: ubuntu
  vars:
    # 실행 시 --extra-vars로 받을 변수 (DB 주소)
    db_endpoint: "{{ db_host }}" 
  
  roles:
    - web_server

```

---

## 5. 실행 및 오케스트레이션 (Orchestration)

**경로: `~/project-main/scripts/deploy_all.sh**`

이 파일 하나로 모든 작업을 순서대로 실행합니다.

```bash
#!/bin/bash
set -e

# [사전 준비] 키페어 이름과 DB 비밀번호 설정
export TF_VAR_key_name="my-key-pair" # AWS 콘솔에 있는 키페어 이름
export TF_VAR_db_password="SuperSecretPassword123!"

echo ">>> [Step 1] Terraform Init & Apply (인프라 구축 시작)"
cd ../terraform
terraform init
# 자동 승인(-auto-approve)으로 실행
terraform apply -auto-approve

echo ">>> [Step 2] DB 엔드포인트 정보 추출"
DB_ENDPOINT=$(terraform output -raw db_endpoint)
echo "DB Endpoint: $DB_ENDPOINT"

echo ">>> [Step 3] 인프라 안정화 대기 (ASG 인스턴스 부팅 대기)"
echo "Waiting 60 seconds for EC2 instances to initialize..."
sleep 60

echo ">>> [Step 4] Ansible Playbook 실행 (소프트웨어 설정)"
cd ../ansible
# 동적 인벤토리(-i aws_ec2.yml) 사용
# SSH 키 파일 경로 지정 필요 (--private-key)
# 테라폼에서 추출한 DB 주소를 앤서블 변수(db_host)로 전달
ansible-playbook -i aws_ec2.yml site.yml \
    --private-key ~/.ssh/my-key-pair.pem \
    --extra-vars "db_host=$DB_ENDPOINT" \
    --ssh-common-args='-o StrictHostKeyChecking=no'

echo ">>> [Step 5] 최종 결과 확인"
cd ../terraform
ALB_DNS=$(terraform output -raw alb_dns_name)
echo "=============================================="
echo " 배포 완료! 아래 주소로 접속하여 확인하세요."
echo " Web Service URL: http://$ALB_DNS"
echo "=============================================="

```

---

## 6. 최종 실행 및 검증 가이드 (Verification)

### 6.1 실행 전 체크리스트 (반드시 확인!)

1. **키페어 생성**: AWS 콘솔 > EC2 > Key Pairs에서 `my-key-pair`를 생성하고 `.pem` 파일을 컨트롤 서버의 `~/.ssh/` 경로에 업로드해야 합니다. (`chmod 400` 필수)
2. **AWS 자격증명**: 컨트롤 서버에서 `aws configure`를 입력하여 Access Key와 Secret Key를 등록해야 합니다.

### 6.2 실행 명령어

```bash
# 컨트롤 서버 접속 후
cd ~/project-main/scripts
chmod +x deploy_all.sh
./deploy_all.sh

```

### 6.3 작동 확인 방법

1. **웹 브라우저 접속**: 스크립트 마지막에 출력된 `http://alb-web-main-xxxx.ap-northeast-2.elb.amazonaws.com` 주소로 접속합니다.
2. **새로고침 테스트**: 페이지를 새로고침할 때마다 `Server IP`가 바뀌는지 확인합니다. (3대의 서버로 로드밸런싱 되는지 확인)
3. **DB 정보 확인**: 화면에 DB Endpoint가 정상적으로 표시되는지 확인합니다.
4. **Auto Scaling 테스트**: (선택) AWS 콘솔에서 웹 서버 하나를 강제로 종료(Terminate)해 봅니다. 잠시 후 자동으로 새 서버가 생성되고, 앤서블을 다시 실행하면 새 서버에도 설정이 적용되는지 확인합니다.

---

**전문가 팁(Pro Tip)**:
실제 운영에서는 `user_data`에 Ansible Pull 방식을 넣거나, 골든 이미지(Packer)를 사용하여 ASG가 새 서버를 만들 때 자동으로 설정이 완료되도록 구성합니다. 하지만 위 방식은 **Terraform과 Ansible의 역할을 가장 명확하게 실습**할 수 있는 표준 구성입니다. 실습 중 에러가 발생하면 `terraform destroy`로 깔끔하게 지우고 다시 시작할 수 있습니다.
