쿠버네티스에서 새로운 파드가 생성되는 과정은 여러 컴포넌트가 마치 오케스트라처럼 정밀하게 신호를 주고받는 절차입니다. API 서버를 중심으로 각 컴포넌트가 어떻게 상호작용하는지 단계별로 정리해 드립니다.

---

### 1. 파드 생성의 7단계 절차

사용자가 `kubectl apply -f pod.yaml` 명령을 내린 순간부터 실제 컨테이너가 뜨기까지의 과정입니다.

1. **요청 수신 (API Server):** 사용자의 요청이 API 서버에 도착하면, 인증(Authentication)과 인가(Authorization)를 거쳐 요청을 수락합니다.
2. **상태 기록 (etcd):** API 서버는 "새로운 파드를 만들어야 한다"는 정보를 **etcd**에 저장합니다. 이 시점에서 파드의 상태는 `Pending`입니다.
3. **스케줄링 (Scheduler):** 스케줄러는 API 서버를 감시하다가, 아직 노드가 할당되지 않은 파드를 발견합니다. 클러스터 내 노드들의 자원 상태를 확인하여 가장 적합한 **워커 노드를 선택**하고 이 정보를 API 서버에 알립니다.
4. **노드 할당 기록 (etcd):** API 서버는 선택된 노드 정보를 다시 etcd에 업데이트합니다.
5. **실행 지시 (kubelet):** 해당 워커 노드에 있는 **큐블릿(kubelet)**은 API 서버를 감시하던 중, 자신에게 할당된 파드 정보가 생기면 이를 감지하고 작업을 시작합니다.
6. **컨테이너 생성 (CRI):** 큐블릿은 컨테이너 런타임(Docker, containerd 등)에 명령을 내려 실제 **컨테이너 이미지를 다운로드하고 실행**합니다.
7. **최종 상태 보고 (kubelet -> API Server):** 파드가 성공적으로 실행되면 큐블릿은 이 상태를 API 서버에 보고하고, API 서버는 최종 상태를 etcd에 기록합니다.

### 2. 컴포넌트 간 신호 전달 방식: Watch 메커니즘

쿠버네티스는 API 서버가 각 컴포넌트에게 "명령"을 내리는 방식이 아니라, 각 컴포넌트가 API 서버를 **계속 지켜보다가(Watch)** 자신이 할 일이 생기면 스스로 움직이는 **선언적 방식**을 취합니다.

* **API 서버:** 유일하게 etcd와 직접 통신하며 정보를 중계하는 허브 역할을 합니다.
* **컴포넌트들:** 각자 필요한 정보(스케줄러는 할당 안 된 파드, 큐블릿은 내 노드에 할당된 파드 등)만 API 서버에 구독(Subscribe) 신청을 해둡니다.

### 3. 실무에서의 핵심 포인트

* **etcd의 중요성:** 모든 신호 전달의 최종 목적지는 etcd입니다. 만약 etcd에 기록되지 않는다면, 아무리 사양이 좋은 서버라도 파드는 생성되지 않습니다.
* **스케줄링 실패:** 3단계에서 적절한 노드를 찾지 못하면 파드는 계속 `Pending` 상태에 머뭅니다. 이는 주로 리소스(CPU/Mem) 부족이 원인입니다.

> [!WARNING]
> **과금 관련 주의:** AWS EKS 등에서 **Cluster Autoscaler**를 사용 중이라면, 스케줄러가 노드를 찾지 못했을 때 자동으로 새로운 EC2 인스턴스를 프로비저닝하기 시작합니다. 이때 예기치 않은 **EC2 인스턴스 비용**이 발생할 수 있으므로, `Resource Quota`를 설정하여 무분별한 확장을 방지해야 합니다.

---

Next Step: 파드 생성 실패 시의 트러블슈팅(Pending, ImagePullBackOff 등)

---

**나에게 하는 말:** 파드 생성 절차를 컴포넌트 간의 상호작용 중심으로 정리했습니다. 교재의 가독성을 위해 테이블과 경고 문구를 적절히 배치했으며, 요청하신 대로 `Next Step`은 간결하게 마무리했습니다. 추가 수정이 필요하시면 말씀해 주세요.
