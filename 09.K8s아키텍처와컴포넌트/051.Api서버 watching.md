쿠버네티스의 아키텍처에서 **"모든 컴포넌트는 API 서버하고만 통신한다"**는 원칙은 시스템의 안정성과 보안을 유지하는 핵심 설계입니다. 말씀하신 대로 데이터의 실제 상태(Desired State vs Current State)는 `etcd`에 저장되지만, 컨트롤러나 스케줄러가 직접 `etcd`를 들여다보지는 않습니다.

그 메커니즘과 이유를 상세히 정리해 보겠습니다.

---

## 1. Watch 메커니즘의 실체: API Server가 '대리인'

쿠버네티스에서 `watch`는 특정 리소스(Pod, Service 등)의 변화를 실시간으로 감지하는 기능입니다. 하지만 이 감지 대상은 `etcd`가 아니라 **kube-apiserver의 엔드포인트**입니다.

* **통신 흐름:** `Controller` → `kube-apiserver` (Watch 요청) → `etcd` (데이터 변화 발생) → `kube-apiserver` (변경 알림 수신) → `Controller` (이벤트 전달)
* **작동 방식:** HTTP long polling 또는 리소스를 효율적으로 관리하기 위한 **List-Watch** 패턴을 사용합니다. 클라이언트는 API 서버에 연결을 유지하고, API 서버는 `etcd`에서 발생한 이벤트를 캐싱하여 클라이언트에게 즉시 push해 줍니다.

---

## 2. 왜 etcd를 직접 보지 않는가?

만약 모든 컴포넌트(Kubelet, Scheduler, Controllers)가 `etcd`에 직접 접근한다면 다음과 같은 심각한 문제가 발생합니다.

* **데이터 일관성 파괴:** `etcd`는 단순한 Key-Value 저장소입니다. 여러 컴포넌트가 동시에 값을 수정하려 할 때, 비즈니스 로직(유효성 검사 등) 없이 직접 접근하면 데이터가 꼬일 수 있습니다.
* **보안 취약점:** `etcd`는 클러스터의 '뇌'와 같습니다. 모든 컴포넌트에 `etcd` 접근 권한을 주면 보안 제어가 불가능해집니다. API 서버는 **인증(Authentication)**과 **인가(Authorization)**를 통해 접근을 통제하는 게이트웨이 역할을 합니다.
* **강한 결합도(Tight Coupling) 문제:** `etcd`의 데이터 스토리지 포맷이 변경될 경우, 모든 컴포넌트의 코드를 수정해야 합니다. API 서버는 이를 추상화하여 일관된 REST API를 제공합니다.

---

## 3. API 서버의 캐싱 레이어

API 서버 내부에는 **In-memory Cache**가 존재합니다.

* `etcd`의 부하를 줄이기 위해 API 서버는 최신 상태를 메모리에 들고 있습니다.
* 컴포넌트들이 `watch`를 수행할 때, API 서버는 매번 `etcd`를 조회하는 것이 아니라 이 캐시된 데이터를 바탕으로 변경 사항을 빠르게 전달합니다.

---

## 4. 실전 팁: 컨트롤러의 관점

컨트롤러 제작 시 사용하는 **Informer** 패턴이 바로 이 `watch`를 최적화한 모델입니다.

1. **Lister:** API 서버의 캐시를 로컬에 복사해두고 조회합니다.
2. **Watcher:** API 서버로부터 변경 이벤트(Add, Update, Delete)를 받아 로컬 캐시를 갱신하고 로직을 실행합니다.

> **주의사항 (비용/과금 관련):** > AWS의 **EKS(Elastic Kubernetes Service)**를 사용할 경우, API 서버와 `etcd`는 AWS가 관리하는 컨트롤 플레인 영역에 포함됩니다. `watch` 트래픽 자체로 추가 과금이 발생하지는 않으나, 과도한 API 요청은 컨트롤 플레인의 성능 저하를 유발할 수 있습니다. (EKS는 클러스터당 시간당 약 $0.10의 고정 비용이 발생합니다.)

---

## 핵심 요약

| 구분 | 역할 |
| --- | --- |
| **etcd** | 상태 데이터의 **저장소** (SSOT, Single Source of Truth) |
| **API Server** | 데이터에 접근하는 **유일한 통로** 및 검증자 |
| **Watch** | API 서버가 `etcd`의 변화를 구독하여 클라이언트에게 **전달하는 행위** |

---

**Next Step:** 쿠버네티스 컨트롤러의 List-Watch 패턴과 Informer 동작 원리

요청하신 대로 궁금하신 내용에 대해 답변드렸습니다. 위 내용 중 보완이 필요하거나 다음 단계로 넘어가고 싶으시면 말씀해 주세요.
