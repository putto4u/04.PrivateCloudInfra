이번 실습에서는 MariaDB 인프라를 구축하는 **Deployment/Service** 파일과, 데이터를 자동으로 주입하는 **Job** 파일을 분리하여 관리하는 방법을 학습합니다. 파일을 분리하면 인프라 생성과 데이터 초기화 단계를 독립적으로 제어할 수 있어 유지보수에 유리합니다.

---

## 1. MariaDB 인프라 구축 (Database Layer)

먼저 데이터베이스 서버 자체를 구동하기 위한 설정입니다. 이전 챕터에서 생성한 NFS 기반의 **PVC**를 연결하여, Pod가 재시작되어도 데이터가 사라지지 않도록 구성합니다.

### **mariadb-infra.yaml**

```yaml
# mariadb-infra.yaml
# 설명: MariaDB 서버 배포 및 네트워크 노출을 위한 매니페스트

apiVersion: v1
kind: Service
metadata:
  name: mariadb-service # 다른 Pod(Job, Backend)들이 접속할 도메인 이름
spec:
  ports:
    - port: 3306 # 서비스 포트
      targetPort: 3306 # 컨테이너 내부 포트
  selector:
    app: mariadb
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mariadb-deployment
spec:
  replicas: 1 # DB 일관성을 위해 1대로 고정
  selector:
    matchLabels:
      app: mariadb
  template:
    metadata:
      labels:
        app: mariadb
    spec:
      containers:
      - name: mariadb
        image: mariadb:10.6
        env:
        - name: MARIADB_ROOT_PASSWORD
          value: "password123" # 루트 비밀번호 설정
        - name: MARIADB_DATABASE
          value: "employees"   # 초기 생성할 데이터베이스 이름
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: db-storage
          mountPath: /var/lib/mysql # 데이터가 물리적으로 저장되는 경로
      volumes:
      - name: db-storage
        persistentVolumeClaim:
          claimName: nfs-pvc-request # 사전에 정의된 NFS PVC 연결

```

---

## 2. 데이터 초기화 자동화 (Data Injection Job)

DB 서버가 준비된 후, 외부의 SQL 파일을 주입하는 작업을 수행합니다. 이 파일은 `ConfigMap`에 등록된 SQL 데이터를 읽어와서 MariaDB 서버로 전송합니다.

### **mariadb-init-job.yaml**

```yaml
# mariadb-init-job.yaml
# 설명: DB 서버 접속 확인 후 employees.sql 데이터를 주입하는 일회성 작업

apiVersion: batch/v1
kind: Job
metadata:
  name: mariadb-init-job
spec:
  template:
    spec:
      containers:
      - name: data-initializer
        image: mariadb:10.6 # mysql 클라이언트 도구가 포함된 이미지 사용
        command: ["/bin/sh", "-c"]
        args:
          - |
            # 1. DB 서버가 응답할 때까지 대기 (Health Check)
            until mariadb-admin ping -h mariadb-service --silent; do
              echo "MariaDB 서비스가 준비될 때까지 대기 중...";
              sleep 3;
            done;

            # 2. 데이터 주입 실행
            echo "데이터 주입 시작: employees.sql";
            mariadb -h mariadb-service -u root -ppassword123 employees < /scripts/employees.sql;
            
            echo "데이터 주입 완료!";
        volumeMounts:
        - name: script-volume
          mountPath: /scripts # SQL 파일이 마운트될 경로
      volumes:
      - name: script-volume
        configMap:
          name: db-init-script # 'employees.sql'이 담긴 컨피그맵 참조
      restartPolicy: OnFailure # 실패 시 성공할 때까지 재시도

```

---

## 3. 작업 절차 및 실행 가이드

본 실습은 파일의 의존성 때문에 반드시 아래 순서대로 진행해야 합니다.

### **Step 1: SQL 파일을 ConfigMap으로 등록**

로컬 마스터 PC에 있는 `employees.sql` 파일을 k8s 오브젝트로 변환합니다.

```bash
kubectl create configmap db-init-script --from-file=employees.sql

```

### **Step 2: MariaDB 인프라 생성**

DB 서버와 서비스를 먼저 배포합니다.

```bash
kubectl apply -f mariadb-infra.yaml

```

### **Step 3: 데이터 주입 Job 실행**

인프라 배포 직후 혹은 서버가 `Running` 상태가 되면 Job을 실행합니다.

```bash
kubectl apply -f mariadb-init-job.yaml

```

### **Step 4: 완료 확인**

Job이 `Completed` 상태가 되었는지 확인하고 DB에 접속해 봅니다.

```bash
kubectl get job mariadb-init-job
# 결과 확인 (테이블 목록 출력)
kubectl exec -it deployment/mariadb-deployment -- mariadb -u root -ppassword123 -e "USE employees; SHOW TABLES;"

```

---

## 4. 실무 전문가 팁 (Best Practices)

* **파일 분리의 이점**: 데이터베이스를 업데이트하거나 패치할 때는 `infra.yaml`만 수정하면 되고, 데이터 초기화가 다시 필요할 때만 `job.yaml`을 재실행(삭제 후 생성)하면 됩니다.
* **리소스 정리**: Job은 완료된 후에도 로그 확인을 위해 Pod를 남겨둡니다. 실습이 끝난 후 클러스터 자원을 아끼려면 `kubectl delete job mariadb-init-job`을 수행하십시오.
* **AWS 과금 주의**:
* **Storage**: NFS를 사용하므로 EBS 비용이 발생하며, 데이터 주입 시 발생하는 디스크 I/O에 따라 IOPS 비용이 추가될 수 있습니다.
* **Compute**: Job 실행을 위해 생성되는 임시 Pod도 클러스터의 자원(vCPU/Mem)을 점유하므로, 수강생이 많을 경우 노드 사양을 충분히 확보해야 합니다.



Next Step: 백엔드(Flask)에서 MariaDB 연동을 위한 환경 변수 설정 및 코드 수정

---

Next Step: Flask 백엔드 DB 연동 가이드
