이번 실습에서는 3-Tier 아키텍처의 **인프라 엔진 선 구축**과 이를 제어하기 위한 **중앙 집중형 환경 설정(ConfigMap/Secret)** 단계를 진행합니다. 모든 계층을 배포하기 전, 클러스터의 네트워크 정보와 보안 인증 정보를 미리 정의하여 관리의 효율성을 높입니다.

---

## 챕터: 3-Tier 인프라 엔진 배포 및 환경 설정 정의

본 단계에서는 실제 데이터 복원이나 서비스 연결을 진행하지 않습니다. 오직 서비스의 뼈대가 되는 **Deployment**와 이를 구성할 **환경 변수 리소스**를 클러스터에 올리는 것에 집중합니다.

### 1. 보안 및 클러스터 네트워크 설정 (Secret & ConfigMap)

민감한 비밀번호와 클러스터의 네트워크 종점 정보, 그리고 향후 사용할 SQL 쿼리문을 미리 리소스로 등록합니다.

#### **01-cluster-config.yaml**

```yaml
# 01-cluster-config.yaml
# 설명: 클러스터 내 서비스 연결 정보 및 공통 설정을 정의합니다.
apiVersion: v1
kind: ConfigMap
metadata:
  name: cluster-config
data:
  # 네트워크 정보 (수강생 PC 및 클러스터 상황에 맞게 수정)
  web-svc-port: "80"
  web-node-port: "30001"
  db-svc-host: "mariadb-service"
  db-svc-port: "3306"
  node-ip: "192.168.1.10" # 예비서버(수강생 PC)의 실제 IP
  
  # 데이터베이스 설정
  db-name: "employees"
  sql-path: "/scripts/employees.sql"

  # 분석 및 조회용 SQL 쿼리 저장
  init-sql: "CREATE DATABASE IF NOT EXISTS employees;"
  analysis-query: |
    SELECT e.emp_no, e.first_name, d.dept_name, s.salary 
    FROM employees e 
    JOIN dept_emp de ON e.emp_no = de.emp_no 
    JOIN departments d ON de.dept_no = d.dept_no 
    JOIN salaries s ON e.emp_no = s.emp_no 
    WHERE s.to_date = '9999-01-01' 
    LIMIT 10;

```

#### **02-cluster-secret.yaml**

```yaml
# 02-cluster-secret.yaml
# 설명: 데이터베이스 인증 정보를 안전하게 분리하여 관리합니다.
apiVersion: v1
kind: Secret
metadata:
  name: cluster-secret
type: Opaque
stringData:
  # 실무에서는 인코딩된 값이 들어가나, 교재 편의상 stringData를 사용합니다.
  root-password: "password123"
  db-user: "admin"
  db-password: "adminpassword"

```

---

### 2. 3-Tier 전체 인프라 선 구축 (Original Deployment)

환경 설정이 주입되기 전, 각 계층의 서버 엔진들만 먼저 클러스터에 배치합니다.

#### **03-frontend-original.yaml**

```yaml
# 03-frontend-original.yaml
# 설명: 웹 서비스를 제공할 Nginx 서버 2대를 기본 상태로 배포합니다.
apiVersion: v1
kind: Service
metadata:
  name: frontend-service
spec:
  type: NodePort
  ports:
    - port: 80
      targetPort: 80
      nodePort: 30001
  selector:
    app: frontend
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: nginx-frontend
        image: nginx:alpine
        ports:
        - containerPort: 80

```

#### **04-backend-original.yaml**

```yaml
# 04-backend-original.yaml
# 설명: 연결 정보가 없는 대기 상태의 Flask 서버 2대를 배포합니다.
apiVersion: v1
kind: Service
metadata:
  name: backend-service
spec:
  ports:
    - port: 5000
  selector:
    app: backend
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: flask-backend
        image: python:3.9-slim
        command: ["python3", "-c"]
        # 아직 환경변수가 주입되지 않아 대기 상태로 유지합니다.
        args: ["print('Backend Engine Standing by...'); import time; time.sleep(3600)"]
        ports:
        - containerPort: 5000

```

#### **05-mariadb-original.yaml**

```yaml
# 05-mariadb-original.yaml
# 설명: 영구 저장소(NFS)가 연결된 MariaDB 서버를 배포합니다.
apiVersion: v1
kind: Service
metadata:
  name: mariadb-service
spec:
  ports:
    - port: 3306
  selector:
    app: mariadb
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mariadb-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mariadb
  template:
    metadata:
      labels:
        app: mariadb
    spec:
      containers:
      - name: mariadb
        image: mariadb:10.6
        env:
        - name: MARIADB_ROOT_PASSWORD
          value: "password123"
        volumeMounts:
        - name: db-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: db-storage
        persistentVolumeClaim:
          claimName: nfs-pvc-request # 기구축된 NFS PVC 사용

```

---

### 3. 작업 절차 및 실행 가이드

1. **환경 설정 및 보안 리소스 생성**: 이후 배포될 엔진들이 참조할 명세서를 먼저 생성합니다.
* `kubectl apply -f 01-cluster-config.yaml`
* `kubectl apply -f 02-cluster-secret.yaml`


2. **전체 인프라 엔진 배포**: 웹, 백엔드, DB 엔진을 순서대로 클러스터에 올립니다.
* `kubectl apply -f 03-frontend-original.yaml`
* `kubectl apply -f 04-backend-original.yaml`
* `kubectl apply -f 05-mariadb-original.yaml`


3. **배포 상태 확인**: 모든 Pod가 정상적으로 `Running` 상태가 되었는지 확인합니다.
* `kubectl get pods -o wide`



---

### 4. 실무 전문가 팁

* **설정의 분리**: ConfigMap에 저장된 `node-ip`나 SQL 쿼리는 나중에 업데이트 배포 단계에서 Pod 내부로 주입되어 실제 비즈니스 로직을 완성하게 됩니다.
* **AWS 과금 주의**:
* **EKS Node 비용**: Pod 5대가 동시에 실행되므로 노드 사양(t3.medium 이상 권장)에 따른 시간당 비용을 체크하십시오.
* **EBS/NFS**: MariaDB가 사용하는 볼륨에 대해 GB당 소액의 과금이 발생합니다. 실습용이므로 대용량 할당은 피하십시오.



Next Step: 주입된 설정을 기반으로 프론트엔드 UI 업데이트 및 백엔드 DB 연동 활성화 로직 구현

---

Next Step: 환경 설정 주입 및 서비스 업데이트 배포 방법

---
IT 전문가로서 아주 날카로운 지적입니다. 강의 교재에서는 수강생들의 가독성을 위해 `stringData` 형식을 사용했지만, **실제 현장 실무에서는 보안상의 이유로 절대 평문을 그대로 노출하지 않습니다.**

Kubernetes 내부에서 이 데이터를 어떻게 처리하고, 실무에서는 어떤 방식으로 숨기는지 아키텍트 관점에서 정리해 드립니다.

---

## 챕터: 실무에서의 Secret 관리와 데이터 보안 기법

Kubernetes의 `Secret` 오브젝트는 기본적으로 데이터를 **Base64**로 인코딩하여 저장합니다. 하지만 Base64는 암호화가 아닌 단순 인코딩이므로, 실무에서는 이를 보완하기 위한 추가 보안 계층을 사용합니다.

### 1. K8S 기본 방식: Base64 인코딩

실무에서 `kubectl apply`를 통해 배포할 때는 아래와 같이 인코딩된 값을 사용합니다.

#### **02-cluster-secret-encoded.yaml**

```yaml
# 02-cluster-secret-encoded.yaml
# 설명: 실무에서 사용하는 Base64 인코딩 방식의 Secret 파일

apiVersion: v1
kind: Secret
metadata:
  name: cluster-secret
type: Opaque
data:
  # 'password123'을 Base64로 변환한 값 (echo -n "password123" | base64)
  root-password: cGFzc3dvcmQxMjM=
  db-user: YWRtaW4=
  db-password: YWRtaW5wYXNzd29yZA==

```

> **[핵심 경고]**: Base64는 누구나 `base64 -d` 명령으로 디코딩할 수 있습니다. 즉, 파일이 유출되면 비밀번호도 유출된 것과 다름없습니다.

---

### 2. 실무에서 사용하는 진짜 "숨기기" 기법 (Advanced Security)

현장 아키텍트들은 Git에 소스 코드를 올릴 때 비밀번호가 포함되는 것을 막기 위해 다음과 같은 솔루션을 도입합니다.

| 방식 | 설명 | 비고 |
| --- | --- | --- |
| **Sealed Secrets** | 공개키 암호화 방식으로 YAML을 암호화하여 Git에 저장. 클러스터 내부에서만 복호화 가능. | 오픈소스(Bitnami) |
| **External Secrets** | AWS Secrets Manager나 HashiCorp Vault에서 직접 값을 가져와 K8S Secret으로 생성. | **실무 선호도 높음** |
| **KMS 연동** | K8S의 저장소(etcd) 자체를 AWS KMS 등으로 암호화하여 물리적 유출 대비. | 클라우드 표준 |

---

### 3. 실무형 Secret 배포 절차 (보안 강화형)

수강생들에게는 다음과 같은 "실무 가이드"를 제공하여 보안 인식을 심어주는 것이 좋습니다.

1. **로컬에서 인코딩**: 터미널에서 직접 값을 추출합니다.
* `echo -n 'password123' | base64`


2. **YAML 작성**: 출력된 값을 `data` 필드에 입력합니다.
3. **파일 접근 제한**: `.yaml` 파일 자체에 대해 OS 권한을 제한합니다. (`chmod 600`)
4. **클러스터 주입**: 배포 후 환경 변수로 매핑하면, Pod 내부에서는 다시 평문으로 인식되어 애플리케이션이 사용할 수 있게 됩니다.

---

### 4. 실무 전문가 팁

* **Secret vs ConfigMap**: "유출되어도 서비스 운영에 지장이 없는가?"를 기준으로 판단하십시오. IP나 포트는 ConfigMap, 인증키나 패스워드는 무조건 Secret입니다.
* **GitOps 주의사항**: ArgoCD나 Terraform 등을 사용할 때 비밀번호를 코드에 박아 넣는 실수를 방지하기 위해 반드시 **환경 변수 파일(.env)**이나 **외부 보안 저장소**를 연동하십시오.
* **AWS 과금 주의**:
* **AWS Secrets Manager**: 비밀번호 1개당 월 **$0.40** 및 API 호출 10,000건당 **$0.05**의 비용이 발생합니다. 대규모 클러스터 운영 시 이 비용도 무시할 수 없으므로 효율적인 캐싱 전략이 필요합니다.



Next Step: AWS Secrets Manager와 EKS를 연동하여 Secret을 자동으로 가져오는 가이드 구현

---

Next Step: 외부 보안 저장소 연동 방법
