이 실습에서는 Kubernetes(k8s) 환경에서 3-Tier 아키텍처(Frontend - Backend - Database)를 구축합니다. 각 계층은 고가용성을 위해 2개의 복제본(Replica)을 유지하며, 최종적으로 사용자가 웹 브라우저를 통해 프론트엔드에서 백엔드를 거쳐 DB 정보까지 확인하는 흐름을 구현합니다.

---

## 1. 시스템 아키텍처 및 작업 절차

본 실습은 다음과 같은 구조로 설계됩니다.

* **Frontend**: Nginx (Pod 2개) - 사용자 UI 및 백엔드 호출 버튼 제공
* **Backend**: Flask (Pod 2개) - DB 연결 테스트 및 정보 반환 API
* **Database**: MySQL (Pod 2개, 읽기 전용 시뮬레이션) - 서비스 정보 저장

### **작업 순서**

1. **DB 계층 생성**: MySQL 디플로이먼트와 내부 통신을 위한 서비스를 생성합니다.
2. **Backend 계층 생성**: Flask 디플로이먼트를 생성하고 DB 서비스 이름으로 연결을 설정합니다.
3. **Frontend 계층 생성**: Nginx 디플로이먼트를 생성하고, ConfigMap을 이용해 커스텀 인덱스 페이지와 백엔드 프록시 설정을 주입합니다.
4. **외부 노출**: 프론트엔드 서비스를 `NodePort` 또는 `LoadBalancer`로 생성하여 브라우저 접속을 허용합니다.

---

## 2. Kubernetes 매니페스트 (YAML)

모든 설정은 `kubectl apply -f <파일명>`으로 실행할 수 있도록 구성되었습니다.

### **Step 1: MySQL Deployment & Service**

실습 편의를 위해 환경 변수로 루트 비밀번호를 설정합니다. 실제 운영 시에는 `Secret` 오브젝트를 사용해야 합니다.

```yaml
# mysql-setup.yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql-service
spec:
  ports:
    - port: 3306
  selector:
    app: mysql
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql-deployment
spec:
  replicas: 2 # 요청하신 대로 2대 배치
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: "password123" # 예시 비밀번호
        - name: MYSQL_DATABASE
          value: "testdb"
        ports:
        - containerPort: 3306

```

### **Step 2: Backend (Flask) Deployment & Service**

백엔드는 DB 서비스 이름(`mysql-service`)을 통해 데이터베이스에 접근합니다.

```yaml
# backend-setup.yaml
apiVersion: v1
kind: Service
metadata:
  name: backend-service
spec:
  ports:
    - port: 5000
      targetPort: 5000
  selector:
    app: backend
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: flask-backend
        image: python:3.9-slim
        # 실습을 위해 인라인 스크립트로 Flask 실행 (실제론 Docker 이미지 빌드 권장)
        command: ["python3", "-c"]
        args:
          - |
            from flask import Flask, jsonify
            import os
            app = Flask(__name__)
            @app.route('/api/db-info')
            def db_info():
                return jsonify({
                    "database_host": "mysql-service",
                    "database_port": 3306,
                    "status": "Connected",
                    "pod_name": os.getenv('HOSTNAME')
                })
            app.run(host='0.0.0.0', port=5000)
        ports:
        - containerPort: 5000

```

### **Step 3: Frontend (Nginx) Deployment & Service**

`ConfigMap`을 사용하여 버튼이 포함된 HTML 파일을 Nginx에 주입합니다.

```yaml
# frontend-setup.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-config
data:
  index.html: |
    <!DOCTYPE html>
    <html>
    <head><title>K8S 3-Tier Demo</title></head>
    <body>
      <h1>Nginx Frontend (Pod 2 Replicas)</h1>
      <p>Welcome to the Kubernetes cluster.</p>
      <button onclick="location.href='/api/db-info'">Go to Backend (DB Info)</button>
    </body>
    </html>
  default.conf: |
    server {
        listen 80;
        location / {
            root /usr/share/nginx/html;
            index index.html;
        }
        location /api/ {
            proxy_pass http://backend-service:5000;
        }
    }
---
apiVersion: v1
kind: Service
metadata:
  name: frontend-service
spec:
  type: NodePort # 외부 접속을 위해 NodePort 설정
  ports:
    - port: 80
      targetPort: 80
      nodePort: 30001 # 브라우저 접속 포트
  selector:
    app: frontend
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: nginx
        image: nginx:alpine
        ports:
        - containerPort: 80
        volumeMounts:
        - name: html-volume
          mountPath: /usr/share/nginx/html/index.html
          subPath: index.html
        - name: config-volume
          mountPath: /etc/nginx/conf.d/default.conf
          subPath: default.conf
      volumes:
      - name: html-volume
        configMap:
          name: nginx-config
      - name: config-volume
        configMap:
          name: nginx-config

```

---

## 3. 실행 방법 및 확인 절차

### **파일 적용**

터미널에서 아래 명령어를 순서대로 실행합니다.

```bash
kubectl apply -f mysql-setup.yaml
kubectl apply -f backend-setup.yaml
kubectl apply -f frontend-setup.yaml

```

### **상태 확인**

모든 Pod가 `Running` 상태인지 확인합니다.

```bash
kubectl get pods

```

### **웹 브라우저 확인 방법**

1. **접속 주소**: `http://<클러스터-노드-IP>:30001`
* 로컬 환경(Docker Desktop/Minikube)인 경우 `http://localhost:30001`로 접속을 시도하세요.


2. **화면 동작**:
* 첫 화면에서 "Nginx Frontend" 메시지와 함께 버튼이 보입니다.
* **버튼 클릭**: `/api/db-info` 경로로 이동하며, 백엔드로부터 전달받은 JSON 데이터(DB 호스트 정보 및 응답한 백엔드 Pod 이름)가 출력됩니다.



---

> **비용 및 주의사항 (AWS 기준)**
> * 본 실습을 AWS **EKS**에서 진행할 경우, `Service` 타입을 `LoadBalancer`로 변경하면 **Classic Load Balancer(CLB) 혹은 NLB**가 자동으로 생성되어 **시간당 비용**이 발생합니다.
> * 사용한 후에는 반드시 `kubectl delete -f .` 명령어로 자원을 회수하여 과금을 방지하세요.
> 
> 

Next Step: k8s 서비스 노출 방식(NodePort vs LoadBalancer vs Ingress)의 차이점과 보안 설정
