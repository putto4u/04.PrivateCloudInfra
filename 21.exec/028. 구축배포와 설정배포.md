이번 실습에서는 3-Tier 아키텍처의 **인프라 엔진 선 구축**과 이를 제어하기 위한 **중앙 집중형 환경 설정(ConfigMap/Secret)** 단계를 진행합니다. 모든 계층을 배포하기 전, 클러스터의 네트워크 정보와 보안 인증 정보를 미리 정의하여 관리의 효율성을 높입니다.

---

## 챕터: 3-Tier 인프라 엔진 배포 및 환경 설정 정의

본 단계에서는 실제 데이터 복원이나 서비스 연결을 진행하지 않습니다. 오직 서비스의 뼈대가 되는 **Deployment**와 이를 구성할 **환경 변수 리소스**를 클러스터에 올리는 것에 집중합니다.

### 1. 보안 및 클러스터 네트워크 설정 (Secret & ConfigMap)

민감한 비밀번호와 클러스터의 네트워크 종점 정보, 그리고 향후 사용할 SQL 쿼리문을 미리 리소스로 등록합니다.

#### **01-cluster-config.yaml**

```yaml
# 01-cluster-config.yaml
# 설명: 클러스터 내 서비스 연결 정보 및 공통 설정을 정의합니다.
apiVersion: v1
kind: ConfigMap
metadata:
  name: cluster-config
data:
  # 네트워크 정보 (수강생 PC 및 클러스터 상황에 맞게 수정)
  web-svc-port: "80"
  web-node-port: "30001"
  db-svc-host: "mariadb-service"
  db-svc-port: "3306"
  node-ip: "192.168.1.10" # 예비서버(수강생 PC)의 실제 IP
  
  # 데이터베이스 설정
  db-name: "employees"
  sql-path: "/scripts/employees.sql"

  # 분석 및 조회용 SQL 쿼리 저장
  init-sql: "CREATE DATABASE IF NOT EXISTS employees;"
  analysis-query: |
    SELECT e.emp_no, e.first_name, d.dept_name, s.salary 
    FROM employees e 
    JOIN dept_emp de ON e.emp_no = de.emp_no 
    JOIN departments d ON de.dept_no = d.dept_no 
    JOIN salaries s ON e.emp_no = s.emp_no 
    WHERE s.to_date = '9999-01-01' 
    LIMIT 10;

```

#### **02-cluster-secret.yaml**

```yaml
# 02-cluster-secret.yaml
# 설명: 데이터베이스 인증 정보를 안전하게 분리하여 관리합니다.
apiVersion: v1
kind: Secret
metadata:
  name: cluster-secret
type: Opaque
stringData:
  # 실무에서는 인코딩된 값이 들어가나, 교재 편의상 stringData를 사용합니다.
  root-password: "password123"
  db-user: "admin"
  db-password: "adminpassword"

```

---

### 2. 3-Tier 전체 인프라 선 구축 (Original Deployment)

환경 설정이 주입되기 전, 각 계층의 서버 엔진들만 먼저 클러스터에 배치합니다.

#### **03-frontend-original.yaml**

```yaml
# 03-frontend-original.yaml
# 설명: 웹 서비스를 제공할 Nginx 서버 2대를 기본 상태로 배포합니다.
apiVersion: v1
kind: Service
metadata:
  name: frontend-service
spec:
  type: NodePort
  ports:
    - port: 80
      targetPort: 80
      nodePort: 30001
  selector:
    app: frontend
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: nginx-frontend
        image: nginx:alpine
        ports:
        - containerPort: 80

```

#### **04-backend-original.yaml**

```yaml
# 04-backend-original.yaml
# 설명: 연결 정보가 없는 대기 상태의 Flask 서버 2대를 배포합니다.
apiVersion: v1
kind: Service
metadata:
  name: backend-service
spec:
  ports:
    - port: 5000
  selector:
    app: backend
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: flask-backend
        image: python:3.9-slim
        command: ["python3", "-c"]
        # 아직 환경변수가 주입되지 않아 대기 상태로 유지합니다.
        args: ["print('Backend Engine Standing by...'); import time; time.sleep(3600)"]
        ports:
        - containerPort: 5000

```

#### **05-mariadb-original.yaml**

```yaml
# 05-mariadb-original.yaml
# 설명: 영구 저장소(NFS)가 연결된 MariaDB 서버를 배포합니다.
apiVersion: v1
kind: Service
metadata:
  name: mariadb-service
spec:
  ports:
    - port: 3306
  selector:
    app: mariadb
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mariadb-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mariadb
  template:
    metadata:
      labels:
        app: mariadb
    spec:
      containers:
      - name: mariadb
        image: mariadb:10.6
        env:
        - name: MARIADB_ROOT_PASSWORD
          value: "password123"
        volumeMounts:
        - name: db-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: db-storage
        persistentVolumeClaim:
          claimName: nfs-pvc-request # 기구축된 NFS PVC 사용

```

---

### 3. 작업 절차 및 실행 가이드

1. **환경 설정 및 보안 리소스 생성**: 이후 배포될 엔진들이 참조할 명세서를 먼저 생성합니다.
* `kubectl apply -f 01-cluster-config.yaml`
* `kubectl apply -f 02-cluster-secret.yaml`


2. **전체 인프라 엔진 배포**: 웹, 백엔드, DB 엔진을 순서대로 클러스터에 올립니다.
* `kubectl apply -f 03-frontend-original.yaml`
* `kubectl apply -f 04-backend-original.yaml`
* `kubectl apply -f 05-mariadb-original.yaml`


3. **배포 상태 확인**: 모든 Pod가 정상적으로 `Running` 상태가 되었는지 확인합니다.
* `kubectl get pods -o wide`



---

### 4. 실무 전문가 팁

* **설정의 분리**: ConfigMap에 저장된 `node-ip`나 SQL 쿼리는 나중에 업데이트 배포 단계에서 Pod 내부로 주입되어 실제 비즈니스 로직을 완성하게 됩니다.
* **AWS 과금 주의**:
* **EKS Node 비용**: Pod 5대가 동시에 실행되므로 노드 사양(t3.medium 이상 권장)에 따른 시간당 비용을 체크하십시오.
* **EBS/NFS**: MariaDB가 사용하는 볼륨에 대해 GB당 소액의 과금이 발생합니다. 실습용이므로 대용량 할당은 피하십시오.



Next Step: 주입된 설정을 기반으로 프론트엔드 UI 업데이트 및 백엔드 DB 연동 활성화 로직 구현

---

Next Step: 환경 설정 주입 및 서비스 업데이트 배포 방법
