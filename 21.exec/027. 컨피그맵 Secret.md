이번 실습에서는 보안성과 유지보수성을 극대화하기 위해 **Secret**과 **ConfigMap**을 각각 별도의 파일로 분리하여 관리하는 방법을 학습합니다. 이는 실무 환경에서 설정 정보(공개 가능)와 기밀 정보(보안 필요)를 서로 다른 권한으로 관리하기 위한 필수적인 단계입니다.

---

## 챕터: 보안 및 설정의 분리 배포를 통한 MariaDB 자동 구축

Kubernetes 리소스를 목적에 따라 파일 단위로 분리하면, 특정 설정만 변경되었을 때 전체 시스템을 건드리지 않고 해당 부분만 재배포할 수 있는 장점이 있습니다.

### 1. 보안 리소스 정의 (Secret)

민감한 비밀번호 정보는 별도의 파일로 관리하여 접근 권한을 제한해야 합니다.

#### **01-mariadb-secret.yaml**

```yaml
# 01-mariadb-secret.yaml
# 설명: 데이터베이스 접속을 위한 루트 및 사용자 비밀번호를 관리합니다.

apiVersion: v1
kind: Secret
metadata:
  name: mariadb-auth
type: Opaque
stringData:
  # 실제 운영 시에는 더 복잡한 비밀번호를 권장합니다.
  root-password: "password123"
  db-user: "admin"
  db-password: "adminpassword"

```

---

### 2. 클러스터 및 쿼리 설정 정의 (ConfigMap)

네트워크 IP, 포트 번호, 그리고 데이터 분석용 SQL 쿼리는 공개 가능한 정보이므로 ConfigMap으로 관리합니다.

#### **02-cluster-config.yaml**

```yaml
# 02-cluster-config.yaml
# 설명: 서비스 연결 정보와 노드 네트워크 정보를 중앙 관리합니다.

apiVersion: v1
kind: ConfigMap
metadata:
  name: cluster-config
data:
  web-svc-port: "80"
  web-node-port: "30001"
  db-svc-host: "mariadb-service"
  db-svc-port: "3306"
  db-name: "employees"
  sql-path: "/scripts/employees.sql"
  node-ip: "192.168.1.10" # 수강생 PC(예비서버)의 실제 IP로 수정

```

#### **03-db-query-config.yaml**

```yaml
# 03-db-query-config.yaml
# 설명: 데이터 주입 후 실행할 사원/부서/연봉 JOIN 분석 쿼리입니다.

apiVersion: v1
kind: ConfigMap
metadata:
  name: db-query-config
data:
  # 사원번호, 사원명, 부서명, 연봉 정보를 결합하여 출력하는 쿼리
  analysis-query: |
    SELECT e.emp_no, e.first_name, d.dept_name, s.salary 
    FROM employees e 
    JOIN dept_emp de ON e.emp_no = de.emp_no 
    JOIN departments d ON de.dept_no = d.dept_no 
    JOIN salaries s ON e.emp_no = s.emp_no 
    WHERE s.to_date = '9999-01-01' 
    ORDER BY s.salary DESC 
    LIMIT 10;

```

---

### 3. MariaDB 인프라 배포 (Deployment & Service)

분리된 Secret과 ConfigMap을 환경 변수로 참조하여 서버를 실행합니다.

#### **04-mariadb-infra.yaml**

```yaml
# 04-mariadb-infra.yaml
# 설명: MariaDB 서버 기동 및 볼륨 마운트 설정을 담당합니다.

apiVersion: v1
kind: Service
metadata:
  name: mariadb-service
spec:
  ports:
    - port: 3306
  selector:
    app: mariadb
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mariadb-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mariadb
  template:
    metadata:
      labels:
        app: mariadb
    spec:
      containers:
      - name: mariadb
        image: mariadb:10.6
        env:
        - name: MARIADB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mariadb-auth
              key: root-password
        - name: MARIADB_DATABASE
          valueFrom:
            configMapKeyRef:
              name: cluster-config
              key: db-name
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: db-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: db-storage
        persistentVolumeClaim:
          claimName: nfs-pvc-request # 기존 구축된 NFS PVC 연동

```

---

### 4. 데이터 주입 및 분석 실행 (Job)

#### **05-mariadb-init-job.yaml**

```yaml
# 05-mariadb-init-job.yaml
# 설명: DB 연결 확인 후 데이터를 복원하고 JOIN 쿼리를 자동 실행합니다.

apiVersion: batch/v1
kind: Job
metadata:
  name: mariadb-init-job
spec:
  template:
    spec:
      containers:
      - name: data-initializer
        image: mariadb:10.6
        command: ["/bin/sh", "-c"]
        env:
        - name: DB_HOST
          valueFrom: { configMapKeyRef: { name: cluster-config, key: db-svc-host } }
        - name: TARGET_DB
          valueFrom: { configMapKeyRef: { name: cluster-config, key: db-name } }
        - name: SQL_FILE
          valueFrom: { configMapKeyRef: { name: cluster-config, key: sql-path } }
        - name: JOIN_QUERY
          valueFrom: { configMapKeyRef: { name: db-query-config, key: analysis-query } }
        - name: ROOT_PASS
          valueFrom: { secretKeyRef: { name: mariadb-auth, key: root-password } }
        args:
          - |
            until mariadb-admin ping -h $DB_HOST --silent; do
              echo "DB 연결 대기 중...";
              sleep 3;
            done;
            echo "1. 데이터베이스 복원 작업 시작...";
            mariadb -h $DB_HOST -u root -p$ROOT_PASS $TARGET_DB < $SQL_FILE;
            
            echo "2. 사원 정보 분석(JOIN) 결과 출력:";
            mariadb -h $DB_HOST -u root -p$ROOT_PASS $TARGET_DB -e "$JOIN_QUERY";
        volumeMounts:
        - name: script-volume
          mountPath: /scripts
      volumes:
      - name: script-volume
        configMap:
          name: db-init-script # employees.sql 데이터가 포함된 ConfigMap
      restartPolicy: OnFailure

```

---

### 5. 작업 절차 및 실행 가이드

1. **초기 데이터 준비**: `employees.sql` 파일을 기반으로 ConfigMap을 미리 생성합니다.
* `kubectl create configmap db-init-script --from-file=employees.sql`


2. **보안 및 설정 파일 배포**:
* `kubectl apply -f 01-mariadb-secret.yaml`
* `kubectl apply -f 02-cluster-config.yaml`
* `kubectl apply -f 03-db-query-config.yaml`


3. **인프라 및 자동 주입 실행**:
* `kubectl apply -f 04-mariadb-infra.yaml`
* `kubectl apply -f 05-mariadb-init-job.yaml`


4. **결과 확인**:
* `kubectl logs job/mariadb-init-job` 명령으로 JOIN 결과 테이블이 출력되는지 확인합니다.



---

### 6. 실무 전문가 팁

* **환경 격리**: 개발용 Secret 파일과 운영용 Secret 파일을 물리적으로 분리하여 관리하고, Git에는 템플릿 파일(`.example`)만 공유하는 습관을 들이십시오.
* **리소스 상태**: Job은 실행이 완료되면 `Completed` 상태가 됩니다. 다시 실행하려면 `kubectl delete job mariadb-init-job`으로 삭제 후 다시 apply 해야 합니다.
* **AWS 과금 주의**:
* **인스턴스 성능**: 데이터 주입 중 CPU 부하가 높으므로, t3.medium 이상의 인스턴스 사용을 권장합니다.
* **EBS 최적화**: 대용량 쓰기 작업 시 gp3 볼륨의 처리량(Throughput) 한도를 확인하십시오.



Next Step: Flask 백엔드 서버에서 환경 변수를 이용한 동적 DB 연동 구현 조치

---

Next Step: Flask DB 연동 API 개발 가이드
