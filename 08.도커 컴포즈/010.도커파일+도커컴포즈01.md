## 도커 파일 빌드와 컴포즈 통합 실습 (Flask & Redis)

프로젝트를 시작하기 전, 파일들이 위치할 구조를 먼저 파악하는 것이 중요합니다. 아래 트리를 참고하여 환경을 구성해 주세요.

---

### 1. 프로젝트 디렉토리 트리 구조

실습에 필요한 파일 구성은 다음과 같습니다. 모든 파일은 하나의 루트 디렉토리 안에 위치해야 합니다.

```text
my-flask-app/
├── app.py              # Flask 애플리케이션 소스 코드
├── requirements.txt    # Python 패키지 의존성 목록
├── Dockerfile          # 애플리케이션 이미지 빌드 정의서
└── compose.yaml        # 다중 컨테이너 서비스 정의서

```

**터미널에서 구조 생성하기**

```bash
# 1. 프로젝트 디렉토리 생성 및 이동
mkdir my-flask-app && cd my-flask-app

# 2. 필요한 빈 파일들 생성
touch app.py requirements.txt Dockerfile compose.yaml

```

---

### 2. 파일별 상세 내용 작성

생성한 파일들에 아래 내용을 각각 복사하여 저장합니다.

#### ① 소스 코드 작성 (`app.py`)

```python
from flask import Flask
from redis import Redis
import os

app = Flask(__name__)
# environment에서 정의할 REDIS_HOST 변수를 읽어옵니다.
redis = Redis(host=os.environ.get('REDIS_HOST', 'redis'), port=6379)

@app.route('/')
def hello():
    count = redis.incr('hits')
    return f'어서오세요! 현재까지 접속 횟수는 {count}번입니다.\n'

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)

```

#### ② 의존성 정의 (`requirements.txt`)

```text
flask
redis

```

#### ③ 빌드 정의서 작성 (`Dockerfile`)

```dockerfile
FROM python:3.9-slim
WORKDIR /app
COPY . .
RUN pip install --no-cache-dir -r requirements.txt
EXPOSE 5000
CMD ["python", "app.py"]

```

#### ④ 서비스 설정 (`compose.yaml`)

```yaml
services:
  web:
    build: .           # 현재 경로(.)의 Dockerfile을 빌드하여 이미지 생성
    ports:
      - "8080:5000"    # 호스트 8080포트를 컨테이너 5000포트에 연결
    environment:
      - REDIS_HOST=redis
    depends_on:
      - redis
  
  redis:
    image: "redis:alpine"
    volumes:
      - redis_data:/data

volumes:
  redis_data:          # 데이터 보존을 위한 명명된 볼륨

```

---

### 3. 실행, 확인 및 삭제 방법

#### [Step 1] 빌드 및 실행 (Build & Run)

```bash
docker compose up -d --build

```

* `--build`: 소스 코드가 수정되었을 때 새롭게 빌드를 수행하도록 강제합니다.

#### [Step 2] 상태 및 로그 확인 (Check)

```bash
# 컨테이너 가동 상태 확인
docker compose ps

# 웹 서비스의 로그 실시간 모니터링
docker compose logs -f web

```

* 브라우저에서 `http://localhost:8080`에 접속하여 숫자가 올라가는지 확인합니다.

#### [Step 3] 삭제 및 정리 (Clean up)

```bash
# 컨테이너 및 네트워크 삭제
docker compose down

# 이미지와 볼륨까지 모두 삭제 (완전 초기화 시 사용)
docker compose down -v --rmi all

```




---




#### [Step 2] 리소스 및 상태 점검 (Status Check)

시스템을 삭제하기 전, 현재 도커 엔진에서 관리되고 있는 리소스의 상태를 확인하는 과정입니다.

**① 서비스 상태 확인 (Compose)**
프로젝트 단위로 실행 중인 컨테이너들의 상태를 요약해서 보여줍니다.

```bash
docker compose ps

```

**출력 예시:**

```text
NAME                   IMAGE               COMMAND                  SERVICE             STATUS              PORTS
my-flask-app-web-1     my-flask-app-web    "python app.py"          web                 running             0.0.0.0:8080->5000/tcp
my-flask-app-redis-1    redis:alpine        "docker-entrypoint.s…"   redis               running             6379/tcp

```

**② 컨테이너 상세 상태 확인 (Container)**
개별 컨테이너의 CPU, 메모리 점유율 등 리소스 사용 현황을 확인합니다.

```bash
docker stats --no-stream

```

**출력 예시:**

```text
CONTAINER ID        NAME                    CPU %               MEM USAGE / LIMIT     NET I/O
a1b2c3d4e5f6        my-flask-app-web-1      0.05%               25.4MiB / 7.67GiB     1.2kB / 0B
g7h8i9j0k1l2        my-flask-app-redis-1    0.12%               4.2MiB / 7.67GiB      0B / 0B

```

**③ 이미지 리스트 확인 (Image)**
빌드된 이미지와 다운로드된 베이스 이미지 목록을 확인합니다.

```bash
docker images

```

**출력 예시:**

```text
REPOSITORY           TAG       IMAGE ID       CREATED          SIZE
my-flask-app-web     latest    9f8e7d6c5b4a   2 minutes ago    145MB
redis                alpine    3e2d1c0b9a8f   3 days ago       32.4MB
python               3.9-slim  5a4b3c2d1e0f   2 weeks ago      122MB

```

**④ 전체 시스템 상태 요약 (System)**
도커 전체의 디스크 사용량과 리소스 개수를 확인합니다.

```bash
docker system df

```

**출력 예시:**

```text
TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE
Images          3         2         299.4MB   122MB (40%)
Containers      2         2         0B        0B
Local Volumes   1         1         512B      0B

```

---

### 4. 삭제 및 정리 (Clean up)

```bash
# 컨테이너 및 네트워크 삭제
docker compose down

# 이미지와 볼륨까지 모두 삭제 (완전 초기화 시 사용)
docker compose down -v --rmi all

```

---

### AWS 비용 및 유료 전환 주의사항

* **Amazon ECR**: 직접 빌드한 이미지를 ECR에 보관 시 **데이터 저장 용량**에 따라 과금이 발생합니다.
* **EC2 NAT Gateway**: 프라이빗 서브넷에서 빌드 시 패키지 다운로드 과정에서 **데이터 처리 비용**이 발생할 수 있습니다.
* **EBS 볼륨**: 볼륨이 유지되는 동안 인스턴스 중지와 관계없이 **스토리지 비용**이 청구됩니다.

Next Step: Docker Compose 로그 관리 및 분석 방법

출력 결과가 모바일이나 웹 환경에서도 정렬이 깨지지 않도록 코드 박스(`text` 포맷) 내부에 배치하였습니다.

Next Step: 로그 관리 및 분석 방법
