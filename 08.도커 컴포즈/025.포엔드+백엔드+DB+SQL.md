## 3-Tier 아키텍처 웹 서비스 구축 실습 (Nginx-Flask-MySQL)

이번 실습은 서비스의 확장성과 보안을 고려한 **3계층(3-Tier) 아키텍처**를 도커 컴포즈로 구현합니다. 클라이언트의 요청을 받는 **Nginx(Frontend)**, 비즈니스 로직을 처리하는 **Flask(Backend)**, 그리고 데이터를 관리하는 **MySQL(Database)**을 하나의 서비스 그룹으로 묶어 완전한 웹 서비스를 구축합니다.

---

### 1. 프로젝트 설명 및 트리 구조

* **Frontend (Nginx)**: 정적 HTML 페이지를 제공하며, 사용자가 버튼을 클릭하면 백엔드 서버로 요청을 전달합니다.
* **Backend (Flask)**: DB에 접속하여 데이터를 쿼리하고 결과를 HTML 형태로 가공하여 반환합니다.
* **Database (MySQL)**: `employees.sql` 데이터를 보유하며 백엔드에 데이터를 제공합니다.

**프로젝트 트리 구조**

```text
full-web-project/
├── compose.yaml           # 전체 서비스 오케스트레이션 정의
├── frontend/
│   ├── Dockerfile         # Nginx 빌드 정의서
│   ├── index.html         # 메인 환영 페이지
│   └── default.conf       # Nginx 설정 파일
├── backend/
│   ├── Dockerfile         # Flask 빌드 정의서
│   ├── app.py             # API 및 DB 연동 로직
│   └── requirements.txt   # Python 의존성
└── db/
    └── employees.sql      # 초기 데이터 주입 SQL

```

---

### 2. 각 서버별 설정 및 도커파일

#### ① Frontend (Nginx)

**`frontend/index.html`**

```html
<!DOCTYPE html>
<html>
<head><title>Welcome</title></head>
<body>
    <h1>안녕하세요! 부서 관리 시스템에 오신 것을 환영합니다.</h1>
    <p>아래 버튼을 클릭하여 현재 등록된 부서 목록을 확인하세요.</p>
    <button onclick="location.href='/api/departments'">부서보기</button>
</body>
</html>

```

**`frontend/default.conf`**

```nginx
server {
    listen 80;
    location / {
        root /usr/share/nginx/html;
        index index.html;
    }
    # /api 경로로 들어오는 요청을 백엔드 Flask 서버로 전달
    location /api/ {
        proxy_pass http://backend:5000/;
    }
}

```

**`frontend/Dockerfile`**

```dockerfile
FROM nginx:alpine
COPY default.conf /etc/nginx/conf.d/default.conf
COPY index.html /usr/share/nginx/html/index.html

```

#### ② Backend (Flask)

**`backend/app.py`**

```python
from flask import Flask
import pymysql
import os

app = Flask(__name__)

def get_db_connection():
    return pymysql.connect(
        host=os.environ.get('DB_HOST', 'db'),
        user=os.environ.get('DB_USER', 'admin'),
        password=os.environ.get('DB_PASSWORD', 'admin123'),
        db=os.environ.get('DB_NAME', 'employees'),
        charset='utf8mb4',
        cursorclass=pymysql.cursors.DictCursor
    )

@app.route('/departments')
def departments():
    try:
        conn = get_db_connection()
        with conn.cursor() as cursor:
            cursor.execute("SELECT dept_no, dept_name FROM departments")
            results = cursor.fetchall()
        conn.close()
        
        # SQL 결과 테이블 생성
        rows = "".join([f"<tr><td>{r['dept_no']}</td><td>{r['dept_name']}</td></tr>" for r in results])
        return f"<h2>부서 조회 결과</h2><table border='1'><tr><th>번호</th><th>부서명</th></tr>{rows}</table><br><a href='/'>뒤로가기</a>"
    except Exception as e:
        return f"DB Error: {str(e)}"

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)

```

**`backend/Dockerfile`**

```dockerfile
FROM python:3.9-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
CMD ["python", "app.py"]

```

---

### 3. 서비스 통합 설정 (`compose.yaml`)

```yaml
services:
  nginx:
    build: ./frontend
    ports:
      - "80:80"
    depends_on:
      - backend

  backend:
    build: ./backend
    environment:
      - DB_HOST=db
      - DB_NAME=employees
      - DB_USER=admin
      - DB_PASSWORD=admin123
    depends_on:
      db:
        condition: service_healthy

  db:
    image: mysql:8.0
    environment:
      - MYSQL_DATABASE=employees
      - MYSQL_ROOT_PASSWORD=root_pass
      - MYSQL_USER=admin
      - MYSQL_PASSWORD=admin123
    volumes:
      - ./db/employees.sql:/docker-entrypoint-initdb.d/employees.sql
      - mysql_data:/var/lib/mysql
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  mysql_data:

```

---

### 4. 상태 확인 및 자원 점검

명령어: `docker compose up -d --build` 실행 후 점검 결과 예시

**① 서비스 및 컨테이너 상태**

```text
NAME                    IMAGE                STATUS              PORTS
full-web-nginx-1        full-web-frontend    running             0.0.0.0:80->80/tcp
full-web-backend-1      full-web-backend     running             5000/tcp
full-web-db-1           mysql:8.0            running (healthy)   3306/tcp

```

**② 이미지 및 시스템 리소스 상태**

```text
[Images]
REPOSITORY           TAG       IMAGE ID       SIZE
full-web-frontend    latest    b2c3d4e5f6a1   24MB
full-web-backend     latest    c3d4e5f6a1b2   155MB
mysql                8.0       d4e5f6a1b2c3   600MB

[System Usage]
TYPE            TOTAL     ACTIVE    SIZE
Images          3         3         779MB
Containers      3         3         18kB
Local Volumes   1         1         120MB

```

---

### 5. 전체 자원 삭제 및 확인

```bash
# 모든 컨테이너, 네트워크, 이미지, 볼륨을 일괄 삭제
docker compose down -v --rmi all

# 확인 명령 (아무것도 출력되지 않아야 함)
docker compose ps
docker volume ls -q

```

---

### 6. 전체 총평

이번 실습을 통해 **Nginx를 Reverse Proxy**로 활용하여 백엔드 서버를 외부에 직접 노출하지 않는 보안 구조를 완성했습니다. 도커 컴포즈의 `healthcheck`와 `depends_on` 조합은 분산 환경에서 서비스 간의 실행 순서를 제어하는 핵심 기술입니다. 또한, 볼륨 마운트를 통한 초기 SQL 주입은 개발 환경 구축의 자동화를 극대화해 줍니다.

---

### AWS 비용 및 유료 전환 주의사항

* **Application Load Balancer (ALB)**: 실무에서 Nginx 대신 AWS ALB를 사용하면 시간당 가동 비용과 처리 데이터량에 따른 비용이 발생합니다.
* **Amazon ECS/EKS**: 위 구조를 클러스터로 배포할 경우 관리형 제어 평면(Control Plane) 비용이 추가될 수 있습니다.
* **Storage**: DB용 EBS 볼륨은 삭제하지 않으면 인스턴스를 꺼두어도 **월별 기가바이트당 비용**이 지속적으로 청구됩니다.

## Next Step: Docker Compose를 활용한 SSL/TLS 보안 인증서(Certbot) 적용 방법

*요청하신 대로 3계층 구조의 완전한 웹 서비스 프로젝트를 구성하고 상태 확인 및 총평까지 정리하였습니다.*

Next Step: SSL 보안 설정 및 도메인 연결 방법
