이 내용은 프론트엔드(Nginx), 백엔드(FastAPI), 데이터베이스(MySQL)가 상호작용하는 3-Tier 아키텍처를 쿠버네티스(K8s) 환경에 배포하는 과정을 다룹니다.

---

## 3-Tier 아키텍처 및 데이터 흐름

이 구조는 클라이언트의 요청이 웹 서버를 거쳐 애플리케이션 서버로 전달되고, 최종적으로 데이터베이스에서 필요한 정보를 조회하여 다시 전달하는 전형적인 기업용 애플리케이션 구조입니다.

### 1. Backend: FastAPI 이미지 생성

FastAPI는 MySQL에 접속하여 `employees`, `departments`, `salaries` 테이블을 조인하고 데이터를 가져옵니다.

**main.py (FastAPI)**

```python
from fastapi import FastAPI
import pymysql

app = FastAPI()

def get_db_connection():
    return pymysql.connect(
        host='mysql-service', # K8s 서비스 이름
        user='admin',
        password='managed_password_12345678', # 실제 운영 환경에선 Secret 사용 권장
        db='employees',
        charset='utf8mb4',
        cursorclass=pymysql.cursors.DictCursor
    )

@app.get("/api/contact")
def get_employees():
    connection = get_db_connection()
    try:
        with connection.cursor() as cursor:
            # 사원, 부서명, 연봉 조인 쿼리
            sql = """
            SELECT e.first_name, e.last_name, d.dept_name, s.salary
            FROM employees e
            JOIN dept_emp de ON e.emp_no = de.emp_no
            JOIN departments d ON de.dept_no = d.dept_no
            JOIN salaries s ON e.emp_no = s.emp_no
            LIMIT 10
            """
            cursor.execute(sql)
            return cursor.fetchall()
    finally:
        connection.close()

```

**Dockerfile (Backend)**

```dockerfile
FROM python:3.9-slim
WORKDIR /app
RUN pip install fastapi uvicorn pymysql
COPY . .
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]

```

---

### 2. Frontend: Nginx 이미지 및 설정

Nginx는 정적 파일을 서빙하며, `/api` 경로로 들어오는 요청을 백엔드 파드로 전달(Reverse Proxy)합니다.

**default.conf (Nginx Config)**

```nginx
server {
    listen 80;
    
    location / {
        root /usr/share/nginx/html;
        index index.html;
    }

    # 백엔드 API 프록시 설정
    location /api {
        proxy_pass http://backend-service:8000;
    }
}

```

**Dockerfile (Frontend)**

```dockerfile
FROM nginx:alpine
COPY default.conf /etc/nginx/conf.d/default.conf
COPY index.html /usr/share/nginx/html/index.html

```

---

### 3. Kubernetes Manifest (Deployment & Service)

각 계층을 파드로 배포하고 서비스로 연결합니다.

**3-tier-deployment.yaml**

```yaml
# 1. MySQL Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql-db
spec:
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: "12345678"
        - name: MYSQL_DATABASE
          value: "employees"
        ports:
        - containerPort: 3306
---
# 2. Backend Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: fastapi
        image: <your-ecr-repo>/backend:latest
        ports:
        - containerPort: 8000
---
# 3. Frontend Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: nginx
        image: <your-ecr-repo>/frontend:latest
        ports:
        - containerPort: 80

```

---

### 4. 서비스 연결 (Service)

파드 간의 통신을 위해 `ClusterIP` 서비스를 생성합니다. (백엔드 서비스 이름은 `backend-service`, DB 서비스 이름은 `mysql-service`로 정의합니다.)

> **AWS 과금 및 보안 주의:** > * **Amazon ECR:** 이미지 저장 용량 및 외부 전송 시 비용이 발생합니다. (무료 티어 범위 확인 요망)
> * **Amazon EBS:** MySQL 데이터를 보존하기 위해 Persistent Volume을 사용할 경우 EBS 비용이 추가됩니다.
> * **Load Balancer:** 프론트엔드를 외부에 노출하기 위해 `LoadBalancer` 타입을 사용하면 시간당 비용이 발생합니다.
> 
> 

---

Next Step: **Kubernetes Secret을 이용한 DB 비번 관리** | **PersistentVolume 설정** | **Ingress 컨트롤러 구축**

이 구성은 기본적인 3-Tier 흐름을 보여줍니다. 실제 DB 데이터(employees)는 별도의 SQL 스크립트를 통해 초기화해야 함을 유의하세요. 요청하신 대로 불필요한 인삿말이나 수식어 없이 작성하였습니다.
